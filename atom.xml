<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Z H</title>
  
  <subtitle>ZH&#39;s blogs</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ghost-guest@github.io/"/>
  <updated>2018-09-11T13:35:10.922Z</updated>
  <id>http://ghost-guest@github.io/</id>
  
  <author>
    <name>Z H</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL</title>
    <link href="http://ghost-guest@github.io/2018/09/11/MySQL/"/>
    <id>http://ghost-guest@github.io/2018/09/11/MySQL/</id>
    <published>2018-09-11T08:37:20.000Z</published>
    <updated>2018-09-11T13:35:10.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h3><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p><ul><li>Mysql是开源的，所以你不需要支付额外的费用。</li><li>Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li><li>MySQL使用标准的SQL数据语言形式。</li><li>Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。</li><li>Mysql对PHP有很好的支持，PHP是目前最流行的Web开发语言。</li><li>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。</li><li>Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。</li></ul><h3 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h3><p>关于mysql的安装请参考链接:<a href="http://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-install.html</a></p><h3 id="MySQL操作"><a href="#MySQL操作" class="headerlink" title="MySQL操作"></a>MySQL操作</h3><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -D 所选择的数据库名 -h 主机名 -u 用户名 -p 密码</span><br><span class="line">mysql&gt; exit # 退出 使用 “quit;” 或 “\q;” 一样的效果</span><br><span class="line">mysql&gt; status;  # 显示当前mysql的version的各种信息</span><br><span class="line">mysql&gt; select version(); # 显示当前mysql的version信息</span><br><span class="line">mysql&gt; show global variables like 'port'; # 查看MySQL端口号</span><br></pre></td></tr></table></figure><h4 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><p>默认数据库：<br>mysql - 用户权限相关数据<br>test - 用于用户测试数据<br>information_schema - MySQL本身架构相关数据</p><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># utf-8</span><br><span class="line">CREATE DATABASE 数据库名称 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line"> </span><br><span class="line"># gbk</span><br><span class="line">CREATE DATABASE 数据库名称 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;</span><br></pre></td></tr></table></figure><h4 id="数据库的查询操作"><a href="#数据库的查询操作" class="headerlink" title="数据库的查询操作"></a>数据库的查询操作</h4><p>1.查询所有字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名;</span><br><span class="line">例：</span><br><span class="line">select * <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure><p>2.查询指定字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 列<span class="number">1</span>,列<span class="number">2</span>,... from 表名;</span><br><span class="line">例:</span><br><span class="line">select name <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure><p>3.使用as给字段取别名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id <span class="keyword">as</span> 序号, name <span class="keyword">as</span> 名字, gender <span class="keyword">as</span> 性别 <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure><p>4.可以通过 as 给表起别名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 如果是单表查询 可以省略表明</span><br><span class="line">select id, name, gender <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line">-- 表名.字段名</span><br><span class="line">select students.id,students.name,students.gender <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line">-- 可以通过 <span class="keyword">as</span> 给表起别名 </span><br><span class="line">select s.id,s.name,s.gender <span class="keyword">from</span> students <span class="keyword">as</span> s;</span><br></pre></td></tr></table></figure><p>5.在select后面列前使用distinct可以消除重复的行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select distinct 列<span class="number">1</span>,... from 表名;</span><br><span class="line">例：</span><br><span class="line">select distinct gender <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure><h4 id="条件查询数据库"><a href="#条件查询数据库" class="headerlink" title="条件查询数据库"></a>条件查询数据库</h4><p>使用where子句对表中的数据筛选，结果为true的行会出现在结果集中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> 表名 where 条件;</span><br><span class="line">例：</span><br><span class="line">select * <span class="keyword">from</span> students where id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>where后面支持多种运算符，进行条件的处理：<br>        比较运算符<br>        逻辑运算符<br>        模糊查询<br>        范围查询<br>        空判断<br>1.比较运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1</span>：查询编号大于<span class="number">3</span>的学生</span><br><span class="line">select * <span class="keyword">from</span> students where id &gt; <span class="number">3</span>;</span><br><span class="line">例<span class="number">2</span>：查询编号不大于<span class="number">4</span>的学生</span><br><span class="line">select * <span class="keyword">from</span> students where id &lt;= <span class="number">4</span>;</span><br><span class="line">例<span class="number">3</span>：查询姓名不是“黄蓉”的学生</span><br><span class="line">select * <span class="keyword">from</span> students where name != <span class="string">'黄蓉'</span>;</span><br><span class="line">例<span class="number">4</span>：查询没被删除的学生</span><br><span class="line">select * <span class="keyword">from</span> students where is_delete=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>2.逻辑运算符<br>or 、and、not<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例5：查询编号大于3的女同学</span><br><span class="line">select * from students where id &gt; 3 and gender=0;</span><br><span class="line">例6：查询编号小于4或没被删除的学生</span><br><span class="line">select * from students where id &lt; 4 or is_delete=0;</span><br></pre></td></tr></table></figure></p><p>3.模糊查询：like</p><ul><li>%表示任意多个任意字符</li><li>_表示一个任意字符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例7：查询姓黄的学生</span><br><span class="line">select * from students where name like &apos;黄%&apos;;</span><br><span class="line">例8：查询姓黄并且“名”是一个字的学生</span><br><span class="line">select * from students where name like &apos;黄_&apos;;</span><br><span class="line">例9：查询姓黄或叫靖的学生</span><br><span class="line">select * from students where name like &apos;黄%&apos; or name like &apos;%靖&apos;;</span><br></pre></td></tr></table></figure><p>4.范围查询<br>in表示在一个非连续的范围内；<br>between … and …表示在一个连续的范围内；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例10：查询编号是1或3或8的学生</span><br><span class="line">select * from students where id in(1,3,8);</span><br><span class="line">例11：查询编号为3至8的学生</span><br><span class="line">select * from students where id between 3 and 8;</span><br><span class="line">例12：查询编号是3至8的男生</span><br><span class="line">select * from students where (id between 3 and 8) and gender=1;</span><br></pre></td></tr></table></figure><p>5.空判断<br>判空is null；<br>判非空is not null；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例13：查询没有填写身高的学生</span><br><span class="line">select * from students where height is null;</span><br><span class="line">例14：查询填写了身高的学生</span><br><span class="line">select * from students where height is not null;</span><br><span class="line">例15：查询填写了身高的男生</span><br><span class="line">select * from students where height is not null and gender=1;</span><br></pre></td></tr></table></figure><p>6.优先级</p><ul><li>优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符</li><li>and比or先运算，如果同时出现并希望先算or，需要结合()使用</li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>将行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推</li><li>默认按照列值从小到大排列（asc）</li><li>asc从小到大排列，即升序</li><li>desc从大到小排序，即降序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例1：查询未删除男生信息，按学号降序</span><br><span class="line">select * from students where gender=1 and is_delete=0 order by id desc;</span><br><span class="line">例2：查询未删除学生信息，按名称升序</span><br><span class="line">select * from students where is_delete=0 order by name;</span><br><span class="line">例3：显示所有的学生信息，先按照年龄从大--&gt;小排序，当年龄相同时 按照身高从高--&gt;矮排序</span><br><span class="line">select * from students  order by age desc,height desc;</span><br></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>总数：count(*)表示计算总行数，括号中写星与列名，结果是相同的<br>最大值：max(列)表示求此列的最大值<br>最小值：min（列）表示求此列的最小值<br>平均值：avg(列)表示求此列的平均值<br>求和：sum（列）表示求此列的和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例1：查询学生总数</span><br><span class="line">select count(*) from students;</span><br><span class="line">例2：查询女生的编号最大值</span><br><span class="line">select max(id) from students where gender=2;</span><br><span class="line">例3：查询未删除的学生最小编号</span><br><span class="line">select min(id) from students where is_delete=0;</span><br><span class="line">例4：查询男生的总年龄</span><br><span class="line">select sum(age) from students where gender=1;</span><br><span class="line"></span><br><span class="line">-- 平均年龄</span><br><span class="line">select sum(age)/count(*) from students where gender=1;</span><br><span class="line">例5：查询未删除女生的编号平均值</span><br><span class="line">select avg(id) from students where is_delete=0 and gender=2;</span><br></pre></td></tr></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>1.group by的含义:将查询结果按照1个或多个字段进行分组，字段值相同的为一组。<br>2.group by可用于单个字段分组，也可用于多个字段分组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">select * from students;</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br><span class="line">| id | name      | age  | height | gender | cls_id | is_delete |</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br><span class="line">|  1 | 小明      |   18 | 180.00 | 女     |      1 |           |</span><br><span class="line">|  2 | 小月月    |   18 | 180.00 | 女     |      2 |          |</span><br><span class="line">|  3 | 彭于晏    |   29 | 185.00 | 男     |      1 |           |</span><br><span class="line">|  4 | 刘德华    |   59 | 175.00 | 男     |      2 |          |</span><br><span class="line">|  5 | 黄蓉      |   38 | 160.00 | 女     |      1 |           |</span><br><span class="line">|  6 | 凤姐      |   28 | 150.00 | 保密   |      2 |          |</span><br><span class="line">|  7 | 王祖贤    |   18 | 172.00 | 女     |      1 |          |</span><br><span class="line">|  8 | 周杰伦    |   36 |   NULL | 男     |      1 |           |</span><br><span class="line">|  9 | 程坤      |   27 | 181.00 | 男     |      2 |           |</span><br><span class="line">| 10 | 刘亦菲    |   25 | 166.00 | 女     |      2 |           |</span><br><span class="line">| 11 | 金星      |   33 | 162.00 | 中性   |      3 |          |</span><br><span class="line">| 12 | 静香      |   12 | 180.00 | 女     |      4 |           |</span><br><span class="line">| 13 | 周杰      |   34 | 176.00 | 女     |      5 |           |</span><br><span class="line">| 14 | 郭靖      |   12 | 170.00 | 男     |      4 |           |</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br><span class="line"></span><br><span class="line">select gender from students group by gender;</span><br><span class="line">+--------+</span><br><span class="line">| gender |</span><br><span class="line">+--------+</span><br><span class="line">| 男     |</span><br><span class="line">| 女     |</span><br><span class="line">| 中性   |</span><br><span class="line">| 保密   |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><p>根据gender字段来分组，gender字段的全部值有4个’男’,’女’,’中性’,’保密’，所以分为了4组 当group by单独使用时，只显示出每组的第一条记录, 所以group by单独使用时的实际意义不大。<br>2.group by + group_concat()</p><ul><li>group_concat(字段名)可以作为一个输出字段来使用，表示分组之后，根据分组结果，使用group_concat()来放置每一组的某字段的值的集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">select gender from students group by gender;</span><br><span class="line">+--------+</span><br><span class="line">| gender |</span><br><span class="line">+--------+</span><br><span class="line">| 男     |</span><br><span class="line">| 女     |</span><br><span class="line">| 中性   |</span><br><span class="line">| 保密   |</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line">select gender,group_concat(name) from students group by gender;</span><br><span class="line">+--------+-----------------------------------------------------------+</span><br><span class="line">| gender | group_concat(name)                                        |</span><br><span class="line">+--------+-----------------------------------------------------------+</span><br><span class="line">| 男     | 彭于晏,刘德华,周杰伦,程坤,郭靖                                 |</span><br><span class="line">| 女     | 小明,小月月,黄蓉,王祖贤,刘亦菲,静香,周杰                        |</span><br><span class="line">| 中性   | 金星                                                       |</span><br><span class="line">| 保密   | 凤姐                                                       |</span><br><span class="line">+--------+-----------------------------------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select gender,group_concat(id) from students group by gender;</span><br><span class="line">+--------+------------------+</span><br><span class="line">| gender | group_concat(id) |</span><br><span class="line">+--------+------------------+</span><br><span class="line">| 男     | 3,4,8,9,14       |</span><br><span class="line">| 女     | 1,2,5,7,10,12,13 |</span><br><span class="line">| 中性   | 11               |</span><br><span class="line">| 保密   | 6                |</span><br><span class="line">+--------+------------------+</span><br></pre></td></tr></table></figure><p>2.group by + 集合函数</p><ul><li>通过group_concat()的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们也可以通过集合函数来对这个值的集合做一些操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">select gender,group_concat(age) from students group by gender;</span><br><span class="line">+--------+----------------------+</span><br><span class="line">| gender | group_concat(age)    |</span><br><span class="line">+--------+----------------------+</span><br><span class="line">| 男     | 29,59,36,27,12       |</span><br><span class="line">| 女     | 18,18,38,18,25,12,34 |</span><br><span class="line">| 中性   | 33                   |</span><br><span class="line">| 保密   | 28                   |</span><br><span class="line">+--------+----------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分别统计性别为男/女的人年龄平均值</span><br><span class="line">select gender,avg(age) from students group by gender;</span><br><span class="line">+--------+----------+</span><br><span class="line">| gender | avg(age) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 男     |  32.6000 |</span><br><span class="line">| 女     |  23.2857 |</span><br><span class="line">| 中性   |  33.0000 |</span><br><span class="line">| 保密   |  28.0000 |</span><br><span class="line">+--------+----------+</span><br><span class="line"></span><br><span class="line">分别统计性别为男/女的人的个数</span><br><span class="line">select gender,count(*) from students group by gender;</span><br><span class="line">+--------+----------+</span><br><span class="line">| gender | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 男     |        5 |</span><br><span class="line">| 女     |        7 |</span><br><span class="line">| 中性   |        1 |</span><br><span class="line">| 保密   |        1 |</span><br><span class="line">+--------+----------+</span><br></pre></td></tr></table></figure><p>3.group by + having</p><ul><li>having 条件表达式：用来分组查询后指定一些条件来输出查询结果</li><li>having作用和where一样，但having只能用于group by</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select gender,count(*) from students group by gender having count(*)&gt;2;</span><br><span class="line">+--------+----------+</span><br><span class="line">| gender | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 男     |        5 |</span><br><span class="line">| 女     |        7 |</span><br><span class="line">+--------+----------+</span><br></pre></td></tr></table></figure><p>5.group by + with rollup</p><ul><li>with rollup的作用是：在最后新增一行，来记录当前列里所有记录的总和.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">select gender,count(*) from students group by gender with rollup;</span><br><span class="line">+--------+----------+</span><br><span class="line">| gender | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 男     |        5 |</span><br><span class="line">| 女     |        7 |</span><br><span class="line">| 中性   |        1 |</span><br><span class="line">| 保密   |        1 |</span><br><span class="line">| NULL   |       14 |</span><br><span class="line">+--------+----------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select gender,group_concat(age) from students group by gender with rollup;</span><br><span class="line">+--------+-------------------------------------------+</span><br><span class="line">| gender | group_concat(age)                         |</span><br><span class="line">+--------+-------------------------------------------+</span><br><span class="line">| 男     | 29,59,36,27,12                            |</span><br><span class="line">| 女     | 18,18,38,18,25,12,34                      |</span><br><span class="line">| 中性   | 33                                        |</span><br><span class="line">| 保密   | 28                                        |</span><br><span class="line">| NULL   | 29,59,36,27,12,18,18,38,18,25,12,34,33,28 |</span><br><span class="line">+--------+-------------------------------------------+</span><br></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>语法：<br>select * from 表名 limit start,count<br>说明：从start开始，获取count条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例1：查询前3行男生信息</span><br><span class="line">select * from students where gender=1 limit 0,3;</span><br></pre></td></tr></table></figure><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>MySQL支持三种类型的连接查询：</p><ul><li>内连接查询：查询的结果为两个表匹配到的数据<br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536658274283.png" alt="enter description here"></li><li>右连接查询：查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用null填充<br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536658328806.png" alt="enter description here"></li><li>左连接查询：查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用null填充<br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536658354228.png" alt="enter description here"><br><strong>语法：</strong><br>select * from 表1 inner或left或right join 表2 on 表1.列 = 表2.列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例1：使用内连接查询班级表与学生表</span><br><span class="line">select * from students inner join classes on students.cls_id = classes.id;</span><br><span class="line">例2：使用左连接查询班级表与学生表</span><br><span class="line">select * from students as s left join classes as c on s.cls_id = c.id;</span><br><span class="line">例3：使用右连接查询班级表与学生表</span><br><span class="line">select * from students as s right join classes as c on s.cls_id = c.id;</span><br><span class="line">例4：查询学生姓名及班级名称</span><br><span class="line">select s.name,c.name from students as s inner join classes as c on s.cls_id = c.id;</span><br></pre></td></tr></table></figure><h4 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h4><p>用一个例子来说明：（省市区）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义表areas，结构如下</span><br><span class="line">id</span><br><span class="line">atitle</span><br><span class="line">pid</span><br><span class="line">说明：</span><br><span class="line">1.因为省没有所属的省份，所以可以填写为null</span><br><span class="line">2.城市所属的省份pid，填写省所对应的编号id</span><br><span class="line">2.这就是自关联，表中的某一列，关联了这个表中的另外一列，但是它们的业务逻辑含义是不一样的，城市信息的pid引用的是省信息的id</span><br><span class="line">4.在这个表中，结构不变，可以添加区县、乡镇街道、村社区等信息</span><br></pre></td></tr></table></figure><p>创建areas表的语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table areas(</span><br><span class="line">    aid int primary key,</span><br><span class="line">    atitle varchar(20),</span><br><span class="line">    pid int</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>从sql文件中导入数据：<br>source areas.sql;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询一共有多少个省</span><br><span class="line">select count(*) from areas where pid is null;</span><br><span class="line">例1：查询省的名称为“山西省”的所有城市</span><br><span class="line">select city.* from areas as city</span><br><span class="line">inner join areas as province on city.pid=province.aid</span><br><span class="line">where province.atitle=&apos;山西省&apos;;</span><br><span class="line">例2：查询市的名称为“广州市”的所有区县</span><br><span class="line">select dis.* from areas as dis</span><br><span class="line">inner join areas as city on city.aid=dis.pid</span><br><span class="line">where city.atitle=&apos;广州市&apos;;</span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>子查询：在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句<br>主查询：主要查询的对象,第一条 select 语句<br>主查询和子查询的关系：<br>1.子查询是嵌入到主查询中<br>2.子查询是辅助主查询的,要么充当条件,要么充当数据源<br>3.子查询是可以独立存在的语句,是一条完整的 select 语句<br>子查询的分类：</p><ul><li>标量子查询: 子查询返回的结果是一个数据(一行一列)</li><li>列子查询: 返回的结果是一列(一列多行)</li><li>行子查询: 返回的结果是一行(一行多列)<br>标量子查询：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询班级学生平均年龄</span><br><span class="line">查询大于平均年龄的学生</span><br><span class="line">select * from students where age &gt; (select avg(age) from students);</span><br></pre></td></tr></table></figure><p>列级子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询还有学生在班的所有班级名字</span><br><span class="line">select name from classes where id in (select cls_id from students);</span><br></pre></td></tr></table></figure><p>行级子查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查找班级年龄最大,身高最高的学生</span><br><span class="line">select * from students where (height,age) = (select max(height),max(age) from students);</span><br></pre></td></tr></table></figure><p>子查询中特定关键字使用：<br>in 范围：格式: 主查询 where 条件 in (列子查询)<br>完整查询语句的执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select distinct *</span><br><span class="line">from 表名</span><br><span class="line">where ....</span><br><span class="line">group by ... having ...</span><br><span class="line">order by ...</span><br><span class="line">limit start,count</span><br></pre></td></tr></table></figure><p>执行顺序为：</p><ul><li>from 表名</li><li>where ….</li><li>group by …</li><li>select distinct *</li><li>having …</li><li>order by …</li><li>limit start,count</li></ul><h3 id="数据的增删改查"><a href="#数据的增删改查" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">查看所有数据库</span><br><span class="line">show databases;</span><br><span class="line">使用数据库</span><br><span class="line">use 数据库名;</span><br><span class="line">查看当前使用的数据库</span><br><span class="line">select database();</span><br><span class="line">创建数据库</span><br><span class="line">create database 数据库名 charset=utf8;</span><br><span class="line">例：</span><br><span class="line">create database python charset=utf8;</span><br><span class="line">删除数据库</span><br><span class="line">drop database 数据库名;</span><br><span class="line">例：</span><br><span class="line">drop database python;</span><br></pre></td></tr></table></figure><h4 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">查看当前数据库中所有表</span><br><span class="line">show tables;</span><br><span class="line">查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line">创建表：auto_increment表示自动增长</span><br><span class="line">CREATE TABLE table_name(</span><br><span class="line">    column1 datatype contrai,</span><br><span class="line">    column2 datatype,</span><br><span class="line">    column3 datatype,</span><br><span class="line">    .....</span><br><span class="line">    columnN datatype,</span><br><span class="line">    PRIMARY KEY(one or more columns)</span><br><span class="line">);</span><br><span class="line">例：创建班级表</span><br><span class="line">create table classes(</span><br><span class="line">    id int unsigned auto_increment primary key not null,</span><br><span class="line">    name varchar(10)</span><br><span class="line">);</span><br><span class="line">例：创建学生表</span><br><span class="line">create table students(</span><br><span class="line">    id int unsigned primary key auto_increment not null,</span><br><span class="line">    name varchar(20) default &apos;&apos;,</span><br><span class="line">    age tinyint unsigned default 0,</span><br><span class="line">    height decimal(5,2),</span><br><span class="line">    gender enum(&apos;男&apos;,&apos;女&apos;,&apos;人妖&apos;,&apos;保密&apos;),</span><br><span class="line">    cls_id int unsigned default 0</span><br><span class="line">)</span><br><span class="line">修改表-添加字段</span><br><span class="line">alter table 表名 add 列名 类型;</span><br><span class="line">例：</span><br><span class="line">alter table students add birthday datetime；</span><br><span class="line">修改表-修改字段：重命名版</span><br><span class="line">alter table 表名 change 原名 新名 类型及约束;</span><br><span class="line">例：</span><br><span class="line">alter table students change birthday birth datetime not null;</span><br><span class="line">修改表-修改字段：不重命名版</span><br><span class="line">alter table 表名 modify 列名 类型及约束;</span><br><span class="line">例：</span><br><span class="line">alter table students modify birth date not null;</span><br><span class="line">修改表-删除字段</span><br><span class="line">alter table 表名 drop 列名;</span><br><span class="line">例：</span><br><span class="line">alter table students drop birthday;</span><br><span class="line">删除表</span><br><span class="line">drop table 表名;</span><br><span class="line">例：</span><br><span class="line">drop table students;</span><br><span class="line">查看表的创建语句</span><br><span class="line">show create table 表名;</span><br><span class="line">例：</span><br><span class="line">show create table classes;</span><br></pre></td></tr></table></figure><h4 id="数据的增删改查-1"><a href="#数据的增删改查-1" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h4><ul><li>查询：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查询所有列</span><br><span class="line">select * from 表名;</span><br><span class="line">例：</span><br><span class="line">select * from classes;</span><br><span class="line">查询指定列</span><br><span class="line">select 列1,列2,... from 表名;</span><br><span class="line">例：</span><br><span class="line">select id,name from classes;</span><br></pre></td></tr></table></figure><ul><li>增加<br>格式:INSERT [INTO] tb_name [(col_name,…)] {VALUES | VALUE} ({expr | DEFAULT},…),(…),…<br>说明：主键列是自动增长，但是在全列插入时需要占位，通常使用0或者 default 或者 null 来占位，插入成功后以实际数据为准。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">全列插入：值的顺序与表中字段的顺序对应。</span><br><span class="line">insert into 表名 values(...)</span><br><span class="line">例：</span><br><span class="line">insert into students values(0,’郭靖‘,1,&apos;蒙古&apos;,&apos;2016-1-2&apos;);</span><br><span class="line">部分列插入：值的顺序与给出的列顺序对应</span><br><span class="line">insert into 表名(列1,...) values(值1,...)</span><br><span class="line">例：</span><br><span class="line">insert into students(name,hometown,birthday) values(&apos;黄蓉&apos;,&apos;桃花岛&apos;,&apos;2016-3-2&apos;);</span><br><span class="line">全列多行插入：值的顺序与给出的列顺序对应</span><br><span class="line">insert into 表名 values(...),(...)...;</span><br><span class="line">例：</span><br><span class="line">insert into classes values(0,&apos;python1&apos;),(0,&apos;python2&apos;);</span><br><span class="line">insert into 表名(列1,...) values(值1,...),(值1,...)...;</span><br><span class="line">例：</span><br><span class="line">insert into students(name) values(&apos;杨康&apos;),(&apos;杨过&apos;),(&apos;小龙女&apos;);</span><br></pre></td></tr></table></figure><ul><li>修改<br>格式: UPDATE tbname SET col1={expr1|DEFAULT} [,col2={expr2|default}]…[where 条件判断]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 列1=值1,列2=值2... where 条件</span><br><span class="line">例：</span><br><span class="line">update students set gender=0,hometown=&apos;北京&apos; where id=5;</span><br></pre></td></tr></table></figure><ul><li>删除<br>DELETE FROM tbname [where 条件判断]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where 条件</span><br><span class="line">例：</span><br><span class="line">delete from students where id=5;</span><br><span class="line">逻辑删除，本质就是修改操作</span><br><span class="line">update students set isdelete=1 where id=1;</span><br></pre></td></tr></table></figure><h3 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –uroot –p 数据库名 &gt; python.sql;</span><br><span class="line"></span><br><span class="line"># 按提示输入mysql的密码</span><br></pre></td></tr></table></figure><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">连接mysql，创建新的数据库</span><br><span class="line">退出连接，执行如下命令</span><br><span class="line">mysql -uroot –p 新数据库名 &lt; python.sql</span><br><span class="line"></span><br><span class="line"># 根据提示输入mysql密码</span><br></pre></td></tr></table></figure><h3 id="MySQL与数据库的交互"><a href="#MySQL与数据库的交互" class="headerlink" title="MySQL与数据库的交互"></a>MySQL与数据库的交互</h3><p>python操作数据库的步骤：<br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536668947862.png" alt="enter description here"><br>1.引入模块<br>from pymysql import *<br>2.Connection 对象<br>用于建立与数据库的连接<br>创建对象：调用connect()方法<br>conn=connect(参数列表)</p><ul><li>参数host：连接的mysql主机，如果本机是’localhost’</li><li>参数port：连接的mysql主机的端口，默认是3306</li><li>参数database：数据库的名称</li><li>参数user：连接的用户名</li><li>参数password：连接的密码</li><li><p>参数charset：通信采用的编码方式，推荐使用utf8<br>对象的方法：</p></li><li><p>close()关闭连接</p></li><li>commit()提交</li><li><p>cursor()返回Cursor对象，用于执行sql语句并获得结果<br>3.cursor对象</p></li><li><p>用于执行sql语句，使用频度最高的语句为select、insert、update、delete</p></li><li><p>获取Cursor对象：调用Connection对象的cursor()方法<br>cs1=conn.cursor()<br>对象的方法：</p></li><li><p>close()关闭</p></li><li>execute(operation [, parameters ])执行语句，返回受影响的行数，主要用于执行insert、update、delete语句，也可以执行create、alter、drop等语句</li><li>fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组</li><li><p>fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回<br>对象的属性：</p></li><li><p>rowcount只读属性，表示最近一次execute()执行后受影响的行数</p></li><li>connection获得当前连接对象<br>实例：<br>1.增删改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from pymysql import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 创建Connection连接</span><br><span class="line">    conn = connect(host=&apos;localhost&apos;,port=3306,database=&apos;jing_dong&apos;,user=&apos;root&apos;,password=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">    # 获得Cursor对象</span><br><span class="line">    cs1 = conn.cursor()</span><br><span class="line">    # 执行insert语句，并返回受影响的行数：添加一条数据</span><br><span class="line">    # 增加</span><br><span class="line">    count = cs1.execute(&apos;insert into goods_cates(name) values(&quot;硬盘&quot;)&apos;)</span><br><span class="line">    #打印受影响的行数</span><br><span class="line">    print(count)</span><br><span class="line"></span><br><span class="line">    count = cs1.execute(&apos;insert into goods_cates(name) values(&quot;光盘&quot;)&apos;)</span><br><span class="line">    print(count)</span><br><span class="line"></span><br><span class="line">    # # 更新</span><br><span class="line">    # count = cs1.execute(&apos;update goods_cates set name=&quot;机械硬盘&quot; where name=&quot;硬盘&quot;&apos;)</span><br><span class="line">    # # 删除</span><br><span class="line">    # count = cs1.execute(&apos;delete from goods_cates where id=6&apos;)</span><br><span class="line"></span><br><span class="line">    # 提交之前的操作，如果之前已经之执行过多次的execute，那么就都进行提交</span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line">    # 关闭Cursor对象</span><br><span class="line">    cs1.close()</span><br><span class="line">    # 关闭Connection对象</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>2.查询一行数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pymysql import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 创建Connection连接</span><br><span class="line">    conn = connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;mysql&apos;,database=&apos;jing_dong&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">    # 获得Cursor对象</span><br><span class="line">    cs1 = conn.cursor()</span><br><span class="line">    # 执行select语句，并返回受影响的行数：查询一条数据</span><br><span class="line">    count = cs1.execute(&apos;select id,name from goods where id&gt;=4&apos;)</span><br><span class="line">    # 打印受影响的行数</span><br><span class="line">    print(&quot;查询到%d条数据:&quot; % count)</span><br><span class="line"></span><br><span class="line">    for i in range(count):</span><br><span class="line">        # 获取查询的结果</span><br><span class="line">        result = cs1.fetchone()</span><br><span class="line">        # 打印查询的结果</span><br><span class="line">        print(result)</span><br><span class="line">        # 获取查询的结果</span><br><span class="line"></span><br><span class="line">    # 关闭Cursor对象</span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>3.查询多行数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from pymysql import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 创建Connection连接</span><br><span class="line">    conn = connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;mysql&apos;,database=&apos;jing_dong&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">    # 获得Cursor对象</span><br><span class="line">    cs1 = conn.cursor()</span><br><span class="line">    # 执行select语句，并返回受影响的行数：查询一条数据</span><br><span class="line">    count = cs1.execute(&apos;select id,name from goods where id&gt;=4&apos;)</span><br><span class="line">    # 打印受影响的行数</span><br><span class="line">    print(&quot;查询到%d条数据:&quot; % count)</span><br><span class="line"></span><br><span class="line">    # for i in range(count):</span><br><span class="line">    #     # 获取查询的结果</span><br><span class="line">    #     result = cs1.fetchone()</span><br><span class="line">    #     # 打印查询的结果</span><br><span class="line">    #     print(result)</span><br><span class="line">    #     # 获取查询的结果</span><br><span class="line"></span><br><span class="line">    result = cs1.fetchall()</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    # 关闭Cursor对象</span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h4><ul><li>sql语句的参数化，可以有效防止sql注入</li><li>注意：此处不同于python的字符串格式化，全部使用%s占位</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pymysql import *</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line"></span><br><span class="line">    find_name = input(&quot;请输入物品名称：&quot;)</span><br><span class="line"></span><br><span class="line">    # 创建Connection连接</span><br><span class="line">    conn = connect(host=&apos;localhost&apos;,port=3306,user=&apos;root&apos;,password=&apos;mysql&apos;,database=&apos;jing_dong&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">    # 获得Cursor对象</span><br><span class="line">    cs1 = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # # 非安全的方式</span><br><span class="line">    # # 输入 &quot; or 1=1 or &quot;   (双引号也要输入)</span><br><span class="line">    # sql = &apos;select * from goods where name=&quot;%s&quot;&apos; % find_name</span><br><span class="line">    # print(&quot;&quot;&quot;sql===&gt;%s&lt;====&quot;&quot;&quot; % sql)</span><br><span class="line">    # # 执行select语句，并返回受影响的行数：查询所有数据</span><br><span class="line">    # count = cs1.execute(sql)</span><br><span class="line"></span><br><span class="line">    # 安全的方式</span><br><span class="line">    # 构造参数列表</span><br><span class="line">    params = [find_name]</span><br><span class="line">    # 执行select语句，并返回受影响的行数：查询所有数据</span><br><span class="line">    count = cs1.execute(&apos;select * from goods where name=%s&apos;, params)</span><br><span class="line">    # 注意：</span><br><span class="line">    # 如果要是有多个参数，需要进行参数化</span><br><span class="line">    # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可 </span><br><span class="line"></span><br><span class="line">    # 打印受影响的行数</span><br><span class="line">    print(count)</span><br><span class="line">    # 获取查询的结果</span><br><span class="line">    # result = cs1.fetchone()</span><br><span class="line">    result = cs1.fetchall()</span><br><span class="line">    # 打印查询的结果</span><br><span class="line">    print(result)</span><br><span class="line">    # 关闭Cursor对象</span><br><span class="line">    cs1.close()</span><br><span class="line">    # 关闭Connection对象</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h3><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>1.视图的含义：<br>通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。<br>视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定义视图：建议以v_开头</span><br><span class="line">create view 视图名称 as select语句;</span><br><span class="line"> 查看视图：查看表会将所有的视图也列出来</span><br><span class="line"> show tables;</span><br><span class="line"> 使用视图：视图的用途就是查询</span><br><span class="line"> select * from v_stu_score;</span><br><span class="line"> 删除视图：</span><br><span class="line"> drop view 视图名称;</span><br><span class="line">例：</span><br><span class="line">drop view v_stu_sco;</span><br></pre></td></tr></table></figure><p>2.视图的作用：</p><ul><li>提高了重用性，就像一个函数</li><li>对数据库重构，却不影响程序的运行</li><li>提高了安全性能，可以对不同的用户</li><li>让数据更加清晰</li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>1.概念<br>所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。<br>2.事务的四大特性</p><ul><li>原子性(Atomicity)<br>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</li><li>一致性(Consistency)<br>数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</li><li>隔离性(Isolation)<br>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）</li><li>持久性(Durability)<br>一旦事务提交，则其所做的修改会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。）<br>3.事务的命令<br>表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中：</span><br><span class="line">begin;</span><br><span class="line">或者</span><br><span class="line">start transaction;</span><br><span class="line">提交事务，命令如下：将缓存中的数据变更维护到物理表中</span><br><span class="line">commit;</span><br><span class="line">回滚事务，命令如下：放弃缓存中变更的数据</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>修改数据的命令会自动的触发事务，包括insert、update、delete</li><li>而在SQL语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>1.索引是什么<br>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。<br>更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。<br>2.索引目的<br>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？<br>3.索引的原理<br>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p><p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。<br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536671756563.png" alt="enter description here"></p><p>4.查看索引<br>show index from 表名;<br>5.创建索引</p><ul><li>如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致</li><li>字段类型如果不是字符串，可以不填写长度部分<br>create index 索引名称 on 表名(字段名称(长度))<br>6.删除索引<br>drop index 索引名称 on 表名;<br>7.注意<br>要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。<br>建立索引会占用磁盘空间。</li></ul><h3 id="账户管理"><a href="#账户管理" class="headerlink" title="账户管理"></a>账户管理</h3><ul><li>在生产环境下操作数据库时，绝对不可以使用root账户连接，而是创建特定的账户，授予这个账户特定的操作权限，然后连接进行操作，主要的操作就是数据的crud</li><li>MySQL账户体系：根据账户所具有的权限的不同，MySQL的账户可以分为以下几种：<br>1.服务实例级账号：，启动了一个mysqld，即为一个数据库实例；如果某用户如root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表<br>2.数据库级别账号：对特定数据库执行增删改查的所有操作<br>3.数据表级别账号：对特定表执行增删改查等所有操作<br>4.字段级别的权限：对某些表的特定字段进行操作<br>5.存储程序级别的账号：对存储程序进行增删改查的操作</li><li>账户的操作主要包括创建账户、删除账户、修改密码、授权权限等</li><li>注意：<br>1.进行账户操作时，需要使用root账户登录，这个账户拥有最高的实例级权限<br>2.通常都使用数据库级操作权限</li></ul><h4 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h4><p><strong>1.查看所有用户</strong></p><ul><li>所有用户及权限信息存储在mysql数据库的user表中</li><li>查看user表的结构<br>desc user;<br>说明：<br>1.Host表示允许访问的主机<br>2.User表示用户名<br>3.authentication_string表示密码，为加密后的值<br>查看所有用户：<br>select host,user,authentication_string from user;<br><strong>2.创建用户</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需要使用实例级账户登录后操作，以root为例</span><br><span class="line">常用权限主要包括：create、alter、drop、insert、update、delete、select</span><br><span class="line">如果分配所有权限，可以使用all privileges</span><br><span class="line">创建账户&amp;授权：</span><br><span class="line">grant 权限列表 on 数据库 to &apos;用户名&apos;@&apos;访问主机&apos; identified by &apos;密码&apos;;</span><br></pre></td></tr></table></figure><p>实例：<br>创建一个laowang的账号，密码为123456，只能通过本地访问, 并且只能对jing_dong数据库中的所有表进行读操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">step1：使用root登录</span><br><span class="line">mysql -uroot -p</span><br><span class="line">回车后写密码，然后回车</span><br><span class="line">step2：创建账户并授予所有权限</span><br><span class="line">grant select on jing_dong.* to &apos;laowang&apos;@&apos;localhost&apos; identified by &apos;123456&apos;;</span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line"> -  可以操作python数据库的所有表，方式为:jing_dong.*</span><br><span class="line"> -  访问主机通常使用 百分号% 表示此账户可以使用任何ip的主机登录访问此数据库</span><br><span class="line"> -  访问主机可以设置成 localhost或具体的ip，表示只允许本机或特定主机访问</span><br><span class="line"> -  查看用户有哪些权限</span><br><span class="line"> show grants for laowang@localhost;</span><br><span class="line"> step3：退出root的登录</span><br><span class="line"> quit</span><br><span class="line"> step4：使用laowang账户登录</span><br><span class="line"> mysql -ulaowang -p</span><br><span class="line">回车后写密码，然后回车</span><br></pre></td></tr></table></figure></p><p> 示例2：<br> 创建一个laoli的账号，密码为12345678，可以任意电脑进行链接访问, 并且对jing_dong数据库中的所有表拥有所有权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on jing_dong.* to &quot;laoli&quot;@&quot;%&quot; identified by &quot;12345678&quot;</span><br></pre></td></tr></table></figure><p><strong>2.账户操作</strong></p><ul><li>修改权限<br>grant 权限名称 on 数据库 to 账户@主机 with grant option;</li><li>修改密码<br>使用root登录，修改mysql数据库的user表：</li><li>使用password()函数进行密码加密</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update user set authentication_string=password(&apos;新密码&apos;) where user=&apos;用户名&apos;;</span><br><span class="line">例：</span><br><span class="line">update user set authentication_string=password(&apos;123&apos;) where user=&apos;laowang&apos;;</span><br></pre></td></tr></table></figure><ul><li>注意修改完成后需要刷新权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">刷新权限：flush privileges</span><br></pre></td></tr></table></figure><ul><li>远程登录（危险慎用）<br>修改 /etc/mysql/mysql.conf.d/mysqld.cnf 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536672661891.png" alt="enter description here"><br>然后重启msyql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><p>在另一台Ubuntu中测试连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">如果依然连不上，可能原因：</span><br><span class="line"></span><br><span class="line">1) 网络不通</span><br><span class="line"></span><br><span class="line">通过 ping xxx.xxx.xx.xxx可以发现网络是否正常</span><br><span class="line"></span><br><span class="line">2)查看数据库是否配置了bind_address参数</span><br><span class="line"></span><br><span class="line">本地登录数据库查看my.cnf文件和数据库当前参数show variables like &apos;bind_address&apos;;</span><br><span class="line"></span><br><span class="line">如果设置了bind_address=127.0.0.1 那么只能本地登录</span><br><span class="line"></span><br><span class="line">3)查看数据库是否设置了skip_networking参数</span><br><span class="line"></span><br><span class="line">如果设置了该参数，那么只能本地登录mysql数据库</span><br><span class="line"></span><br><span class="line">4)端口指定是否正确</span><br></pre></td></tr></table></figure><ul><li>删除用户<br>1.语法1：使用root登录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop user &apos;用户名&apos;@&apos;主机&apos;;</span><br><span class="line">例：</span><br><span class="line">drop user &apos;laowang&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure><p>2.使用root登录，删除mysql数据库的user表中数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delete from user where user=&apos;用户名&apos;;</span><br><span class="line">例：</span><br><span class="line">delete from user where user=&apos;laowang&apos;;</span><br><span class="line"></span><br><span class="line">-- 操作结束之后需要刷新权限</span><br><span class="line">flush privileges</span><br></pre></td></tr></table></figure><p>3.忘记 root 账户密码怎么办?<br> 到时候再来查<a href="http://blog.csdn.net/lxpbs8851/article/details/10895085" target="_blank" rel="noopener">http://blog.csdn.net/lxpbs8851/article/details/10895085</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySQL简介&quot;&gt;&lt;a href=&quot;#MySQL简介&quot; class=&quot;headerlink&quot; title=&quot;MySQL简介&quot;&gt;&lt;/a&gt;MySQL简介&lt;/h3&gt;&lt;p&gt;MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。My
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>itsdangerous</title>
    <link href="http://ghost-guest@github.io/2018/09/11/itsdangerous/"/>
    <id>http://ghost-guest@github.io/2018/09/11/itsdangerous/</id>
    <published>2018-09-11T06:59:07.000Z</published>
    <updated>2018-09-11T08:34:38.621Z</updated>
    
    <content type="html"><![CDATA[<h4 id="itsdangerous介绍"><a href="#itsdangerous介绍" class="headerlink" title="itsdangerous介绍"></a>itsdangerous介绍</h4><p>有时候你想向不可信的环境发送一些数据，但如何安全完成这个任务呢？解决的方法就是签名。使用只有你自己知道的密钥，来加密签名你的数据，并把加密后的数据发给别人。当你取回数据时，你就可以确保没人篡改过这份数据。<br>诚然，接收者可以破译内容，来看看你的包裹里有什么，但他们没办法修改你的内容，除非他们也有你的密钥。所以只要你保管好你的密钥，并且密钥足够复杂，一切就OK了。<br>itsdangerous内部默认使用了HMAC和SHA1来签名，基于 Django 签名模块。它也支持JSON Web 签名 (JWS)。这个库采用BSD协议，由Armin Ronacher编写，而大部分设计与实现的版权归Simon Willison和其他的把这个库变为现实的Django爱好者们。<br>itsdangerous中dumps和loads：<br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536654330380.png" alt="enter description here"><br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536654364997.png" alt="enter description here"><br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536654410718.png" alt="enter description here"></p><h3 id="json，pickle-itsdangerous中的loads、dumps-的对比分析"><a href="#json，pickle-itsdangerous中的loads、dumps-的对比分析" class="headerlink" title="json，pickle, itsdangerous中的loads、dumps 的对比分析"></a>json，pickle, itsdangerous中的loads、dumps 的对比分析</h3><h4 id="1-json中的json-dumps和json-loads"><a href="#1-json中的json-dumps和json-loads" class="headerlink" title="1.json中的json.dumps和json.loads:"></a>1.json中的json.dumps和json.loads:</h4><p> json.dumps(): 将一个Python数据类型进行json格式的编码解析(dict转成str)<br> json.loads():将json格式的基于字典的字符串转换成Python数据类型（str转成dict）<br> <img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536654441240.png" alt="enter description here"><br>    扩展：json.loads和json.load，json.dumps和json.dump的区别<br>     json.dump是将python数据保存成json。主要配合json.load来使用。<br>      json.dump(x,f)，x是对象，f是文件对象，将json数据写入到f文本文件当中。<br>      json.load是读取json数据 。主要配合json.dump来使用.<br>     <img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536654460317.png" alt="enter description here"></p><h4 id="2-pickle中的pickle-dumps和pickle-loads："><a href="#2-pickle中的pickle-dumps和pickle-loads：" class="headerlink" title="2. pickle中的pickle.dumps和pickle.loads："></a>2. pickle中的pickle.dumps和pickle.loads：</h4><p>   pickle.dumps():将obj对象序列化并返回一个bytes对象(某一个数据类型转成bytes).<br>    pickle.loads():将bytes反序列化并返回一个对象(bytes转成之前的数据类型).<br>    <img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536654507656.png" alt="enter description here"><br>    扩展：pickle.loads和pickle.load，pickle.dumps和pickle.dump的区别<br>pickle.dump()方法将obj对象序列化为字节（bytes）写入到file文件中<br>pickle.load()从一个对象文件中读取序列化数据，将其反序列化之后返回一个对象.<br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536654572885.png" alt="enter description here"></p><h4 id="3-json-pickle-itsdangerous对比总结"><a href="#3-json-pickle-itsdangerous对比总结" class="headerlink" title="3.json-pickle-itsdangerous对比总结:"></a>3.json-pickle-itsdangerous对比总结:</h4><p>1-pickle不是用于多种语言间的数据传输，它仅作为python对象的持久化，只针对python的数据类型；而json可以支持更多语言的序列化和反序列化，在python中序列化一个自定义的类对象时，会抛出一个 TypeError;<br>2-json的序列化输出是文本对象是str类型，而pickle序列化的输出是二进制字节-bytes</p><p>3-json可读性优于pickle。</p><p>4-itsdangerous也提供了一个与json或pickle类似的序列化接口。（它内部默认使用simplejson，但是可以通过子类进行修改）</p><p>5-pickle:就是将python数据转成原始的二进制数据；<br>    itsdangerous:就是通过密钥secret-key进行加密处理。多用于生成token。</p><h4 id="4-jsonify和json-dumps"><a href="#4-jsonify和json-dumps" class="headerlink" title="4.jsonify和json.dumps()"></a>4.jsonify和json.dumps()</h4><p>sonify的作用实际上就是将我们传入的json形式数据序列化成为json字符串，作为响应的body，并且设置响应的Content-Type为application/json，构造出响应返回至客户端。jsonify的部分源码如下：<br><img src="http://pevsyd86b.bkt.clouddn.com/blogs/1536654600335.png" alt="enter description here"></p><p>jsonify将dict类型转变为json对象。json.dumps只是将dict类型转化为str类型，并非一个json对象。<br>jsonify其实也是用dumps方法转换成了json格式的字符串，但是jsonify会根据http协议的body进行格式重新编排。而json.dumps只是单纯的将dict类型转化为str类型，可以直接return json.dumps(data)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;itsdangerous介绍&quot;&gt;&lt;a href=&quot;#itsdangerous介绍&quot; class=&quot;headerlink&quot; title=&quot;itsdangerous介绍&quot;&gt;&lt;/a&gt;itsdangerous介绍&lt;/h4&gt;&lt;p&gt;有时候你想向不可信的环境发送一些数据，但如何
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python三大神器</title>
    <link href="http://ghost-guest@github.io/2018/09/10/python%E4%B8%89%E5%A4%A7%E7%A5%9E%E5%99%A8/"/>
    <id>http://ghost-guest@github.io/2018/09/10/python三大神器/</id>
    <published>2018-09-10T09:31:52.000Z</published>
    <updated>2018-09-11T06:57:50.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python三大神器"><a href="#python三大神器" class="headerlink" title="python三大神器"></a>python三大神器</h3><p>装饰器、生成器、迭代器</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>在说装饰器之前先了解一下闭包函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 外函数outer()</span><br><span class="line">def outer():</span><br><span class="line">    # 外函数局部变量，对于内函数来说相当于全局变量</span><br><span class="line">    number = <span class="number">10</span></span><br><span class="line">    # 内函数   </span><br><span class="line">    def inner():</span><br><span class="line">        # 外函数数据的引用      </span><br><span class="line">        nonlocal number     </span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">    # 返回值是内函数inner的引用</span><br><span class="line">    <span class="keyword">return</span> inner        </span><br><span class="line"></span><br><span class="line"># 调用outer函数，用func接收inner函数的引用</span><br><span class="line">func = outer()</span><br><span class="line"># 调用inner函数     </span><br><span class="line">func()</span><br></pre></td></tr></table></figure><ul><li>在一个函数里边定义了一个函数 </li><li>内函数可能会用到外函数的数据 </li><li>外函数一定有返回值，而且是内函数的引用</li></ul><h4 id="装饰器的定义"><a href="#装饰器的定义" class="headerlink" title="装饰器的定义"></a>装饰器的定义</h4><p>闭包的延伸，外函数传入函数的引用，而且内函数返回函数的调用就是装饰器。</p><h4 id="装饰器的作用"><a href="#装饰器的作用" class="headerlink" title="装饰器的作用"></a>装饰器的作用</h4><p>在不修改函数体的前提下，在函数前面添加功能比如验证等 。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>直接调用内函数，先执行内函数函数体，即验证的部分，在内函数的返回值的地方返回传入函数的调用，即不被修改的函数体。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def outer(func):</span><br><span class="line">    def inner():</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"># 装饰器的使用  @ ：相当于 func = outer(func) </span><br><span class="line"># 即把func的引用替换成outer的返回值，也就是内函数的引用</span><br><span class="line"># 然后在内函数中返回原本func的引用的调用，即func的函数体</span><br><span class="line">@outer</span><br><span class="line">def func():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h4 id="内置装饰器"><a href="#内置装饰器" class="headerlink" title="内置装饰器"></a>内置装饰器</h4><p>python中内置的装饰器有三个：staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。<br>functools模块提供了两个装饰器：<br>1.wraps(wrapped[, assigned][, updated]):<br>这是一个很有用的装饰器。看过前一篇反射的朋友应该知道，函数是有几个特殊属性比如函数名，在被装饰后，上例中的函数名foo会变成包装函数的名字wrapper，如果你希望使用反射，可能会导致意外的结果。这个装饰器可以解决这个问题，它能将装饰过的函数的特殊属性保留。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time <span class="keyword">import</span> functools </span><br><span class="line"></span><br><span class="line">def timeit(func): </span><br><span class="line"></span><br><span class="line">   @functools.wraps(func) </span><br><span class="line">   def wrapper(): </span><br><span class="line">      start = time.clock() </span><br><span class="line">      func()</span><br><span class="line">      end =time.clock()</span><br><span class="line">      print ‘used:’, end - start</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">@timeit</span><br><span class="line">def foo(): </span><br><span class="line">   print ‘<span class="keyword">in</span> foo()’</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">print foo.__name__</span><br></pre></td></tr></table></figure><p>首先注意第5行，如果注释这一行，foo.name将是’wrapper’。另外相信你也注意到了，这个装饰器竟然带有一个参数。实际上，他还有另外两个可选的参数，assigned中的属性名将使用赋值的方式替换，而updated中的属性名将使用update的方式合并，你可以通过查看functools的源代码获得它们的默认值。对于这个装饰器，相当于wrapper = functools.wraps(func)(wrapper)。<br>2.total_ordering(cls):<br>这个装饰器在特定的场合有一定用处，但是它是在Python 2.7后新增的。它的作用是为实现了至少lt、le、gt、ge其中一个的类加上其他的比较方法，这是一个类装饰器。如果觉得不好理解，不妨仔细看看这个装饰器的源代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def total_ordering(cls):</span><br><span class="line">      <span class="string">""</span><span class="string">"Class decorator that fills in missing ordering methods"</span><span class="string">""</span></span><br><span class="line">      convert = &#123;</span><br><span class="line">          <span class="string">'__lt__'</span>: [(<span class="string">'__gt__'</span>, lambda self, <span class="attr">other</span>: other &lt; self),</span><br><span class="line">                     (<span class="string">'__le__'</span>, lambda self, <span class="attr">other</span>: not other &lt; self),</span><br><span class="line">                     (<span class="string">'__ge__'</span>, lambda self, <span class="attr">other</span>: not self &lt; other)],</span><br><span class="line">          <span class="string">'__le__'</span>: [(<span class="string">'__ge__'</span>, lambda self, <span class="attr">other</span>: other &lt;= self),</span><br><span class="line">                     (<span class="string">'__lt__'</span>, lambda self, <span class="attr">other</span>: not other &lt;= self),</span><br><span class="line">                     (<span class="string">'__gt__'</span>, lambda self, <span class="attr">other</span>: not self &lt;= other)],</span><br><span class="line">          <span class="string">'__gt__'</span>: [(<span class="string">'__lt__'</span>, lambda self, <span class="attr">other</span>: other &gt; self),</span><br><span class="line">                     (<span class="string">'__ge__'</span>, lambda self, <span class="attr">other</span>: not other &gt; self),</span><br><span class="line">                     (<span class="string">'__le__'</span>, lambda self, <span class="attr">other</span>: not self &gt; other)],</span><br><span class="line">          <span class="string">'__ge__'</span>: [(<span class="string">'__le__'</span>, lambda self, <span class="attr">other</span>: other &gt;= self),</span><br><span class="line">                     (<span class="string">'__gt__'</span>, lambda self, <span class="attr">other</span>: not other &gt;= self),</span><br><span class="line">                     (<span class="string">'__lt__'</span>, lambda self, <span class="attr">other</span>: not self &gt;= other)]</span><br><span class="line">      &#125;</span><br><span class="line">      roots = set(dir(cls)) &amp; set(convert)</span><br><span class="line">      <span class="keyword">if</span> not roots:</span><br><span class="line">          raise ValueError(<span class="string">'must define at least one ordering operation: &lt; &gt; &lt;= &gt;='</span>)</span><br><span class="line">      root = max(roots)       # prefer __lt__ to __le__ to __gt__ to __ge__</span><br><span class="line">      <span class="keyword">for</span> opname, opfunc <span class="keyword">in</span> convert[root]:</span><br><span class="line">          <span class="keyword">if</span> opname not <span class="keyword">in</span> roots:</span><br><span class="line">              opfunc.__name__ = opname</span><br><span class="line">              opfunc.__doc__ = getattr(int, opname).__doc__</span><br><span class="line">              setattr(cls, opname, opfunc)</span><br><span class="line">      <span class="keyword">return</span> cls</span><br></pre></td></tr></table></figure><h4 id="进阶装饰器"><a href="#进阶装饰器" class="headerlink" title="进阶装饰器"></a>进阶装饰器</h4><p>1.带有参数的装饰器：<br>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出log信息，而且还需指定log的级别，那么装饰器就会是这样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def logging(level):</span><br><span class="line">    def wrapper(func):</span><br><span class="line">        def inner_wrapper(*args, **kwargs):</span><br><span class="line">            print <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=level,</span><br><span class="line">                func=func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">@logging(level=<span class="string">'INFO'</span>)</span><br><span class="line">def say(something):</span><br><span class="line">    print <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line"></span><br><span class="line"># 如果没有使用@语法，等同于</span><br><span class="line"># say = logging(level='INFO')(say)</span><br><span class="line"></span><br><span class="line">@logging(level=<span class="string">'DEBUG'</span>)</span><br><span class="line">def <span class="keyword">do</span>(something):</span><br><span class="line">    print <span class="string">"do &#123;&#125;..."</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">do</span>(<span class="string">"my work"</span>)</span><br></pre></td></tr></table></figure><p>当带参数的装饰器被打在某个函数上时，比如@logging(level=’DEBUG’)，它其实是一个函数，会马上被执行，只要这个它返回的结果是一个装饰器时，那就没问题。细细再体会一下。<br>2.基于类实现的装饰器<br>装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了<strong>call</strong>()方法，那么这个对象就是callable的。<br>用类来实现也是也可以的。我们可以让类的构造函数<strong>init</strong>()接受一个函数，然后重载<strong>call</strong>()并返回一个函数，也可以达到装饰器函数的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class logging(object):</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print <span class="string">"[DEBUG]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">            func=self.func.__name__)</span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line">@logging</span><br><span class="line">def say(something):</span><br><span class="line">    print <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br></pre></td></tr></table></figure><p>3.带有参数的类装饰器<br>如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接受的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载<strong>call</strong>方法是就需要接受一个函数并返回一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class logging(object):</span><br><span class="line">    def __init__(self, level=<span class="string">'INFO'</span>):</span><br><span class="line">        self.level = level</span><br><span class="line">        </span><br><span class="line">    def __call__(self, func): # 接受函数</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            print <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=self.level,</span><br><span class="line">                func=func.__name__)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        return wrapper  #返回函数</span><br><span class="line"></span><br><span class="line">@logging(level=<span class="string">'INFO'</span>)</span><br><span class="line">def say(something):</span><br><span class="line">    print <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退，不过这也没什么，因为人们很少在迭代途中往后退。另外，迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>a）访问者不需要关心迭代器内部的结构，仅需通过next()方法或不断去取下一个内容</p><p>b）不能随机访问集合中的某个值 ，只能从头到尾依次访问</p><p>c）访问到一半时不能往回退</p><p>d）便于循环比较大的数据集合，节省内存</p><p>e）也不能复制一个迭代器。如果要再次（或者同时）迭代同一个对象，只能去创建另一个迭代器对象。enumerate()的返回值就是一个迭代器。</p><h4 id="可迭代对象和可迭代器"><a href="#可迭代对象和可迭代器" class="headerlink" title="可迭代对象和可迭代器"></a>可迭代对象和可迭代器</h4><p>可以直接作用于for循环的对象统称为可迭代对象(Iterable)。</p><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器(Iterator)。</p><p>所有的Iterable均可以通过内置函数iter()来转变为Iterator。<br>如何判断一个对象是可迭代对象呢？可以通过collections模块的Iterable类型判断。<br>可迭代对象：迭代器是一个对象，不是一个函数；是一个什么样的对象呢？就是只要它定义了可以返回一个迭代器的<strong>iter</strong>方法，或者定义了可以支持下标索引的<strong>getitem</strong>方法，那么它就是一个可迭代对象。<br>迭代器：任何实现了<strong>iter</strong>和<strong>next</strong>()（python2中实现next()）方法的对象都是迭代器，<strong>iter</strong>返回迭代器自身，<strong>next</strong>返回容器中的下一个值。</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>理解了迭代器以后，生成器就会简单很多，因为生成器其实是一种特殊的迭代器。不过这种迭代器更加优雅。它不需要再像上面的类一样写<strong>iter</strong>()和<strong>next</strong>()方法了，只需要一个yiled关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。<br>语法上说，生成器函数是一个带yield关键字的函数。<br>调用生成器函数后会得到一个生成器对象，这个生成器对象实际上就是一个特殊的迭代器，拥有<strong>iter</strong>()和<strong>next</strong>()方法。<br>小结：<br>按照鸭子模型理论，生成器就是一种迭代器，可以使用for进行迭代。</p><p>第一次执行next(generator)时，会执行完yield语句后程序进行挂起，所有的参数和状态会进行保存。再一次执行next(generator)时，会从挂起的状态开始往后执行。在遇到程序的结尾或者遇到StopIteration时，循环结束。</p><p>可以通过generator.send(arg)来传入参数，这是协程模型。</p><p>可以通过generator.throw(exception)来传入一个异常。throw语句会消耗掉一个yield。可以通过generator.close()来手动关闭生成器。</p><p>next()等价于send(None)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python三大神器&quot;&gt;&lt;a href=&quot;#python三大神器&quot; class=&quot;headerlink&quot; title=&quot;python三大神器&quot;&gt;&lt;/a&gt;python三大神器&lt;/h3&gt;&lt;p&gt;装饰器、生成器、迭代器&lt;/p&gt;
&lt;h3 id=&quot;装饰器&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>列表生成式与匿名函数</title>
    <link href="http://ghost-guest@github.io/2018/09/08/%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://ghost-guest@github.io/2018/09/08/列表生成式与匿名函数/</id>
    <published>2018-09-08T13:08:23.000Z</published>
    <updated>2018-09-10T08:27:27.867Z</updated>
    
    <content type="html"><![CDATA[<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><p>[x * x for x in range(1, 11)] 就是一个列表生成式, 它的基础语法是:<br>[exp for iter_var in iterable]<br>首先迭代 iterable 里所有内容, 每一次迭代, 都把 iterable 里相应内容放到 iter_var 中, 再在表达式 exp 中应用该 iter_var 的内容, 最后用表达式的计算值生成一个新的列表.<br>例如, 把一个 list 中所有的字符串变成小写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line">[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]</span><br><span class="line">&gt;&gt;&gt; [<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="string">'ibm'</span>, <span class="string">'apple'</span>]</span><br></pre></td></tr></table></figure><h3 id="map（）函数"><a href="#map（）函数" class="headerlink" title="map（）函数"></a>map（）函数</h3><p>map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">b = [x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line">print(b)</span><br><span class="line">c = [x <span class="keyword">for</span> x <span class="keyword">in</span> map(lambda x, <span class="attr">y</span>: x + y, a, b)]</span><br><span class="line">print(c)</span><br><span class="line"># d = [x for x in c]</span><br><span class="line"># print(d)</span><br><span class="line">l4 = map(lambda x, <span class="attr">y</span>: (x ** y, x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l4:</span><br><span class="line">    print(i)</span><br><span class="line"># l4 = map(lambda x, y: (x ** y, x + y), [1, 2, 3], [1, 2, 'a'])</span><br><span class="line"># for i in l4:</span><br><span class="line">#     print(i)</span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x = map(None, l)</span><br><span class="line">print(x)</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">&lt;map object at <span class="number">0x00000191E293EE48</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="filter（）函数"><a href="#filter（）函数" class="headerlink" title="filter（）函数"></a>filter（）函数</h3><p>filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。<br>例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(x):</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后，利用filter()过滤掉偶数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;filter(is_odd, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>])</span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure><p>利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def is_not_empty(s):</span><br><span class="line">    <span class="keyword">return</span> s and len(s.strip()) &gt; <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;filter(is_not_empty, [<span class="string">'test'</span>, None, <span class="string">''</span>, <span class="string">'str'</span>, <span class="string">'  '</span>, <span class="string">'END'</span>])</span><br><span class="line">&gt;&gt;&gt;[<span class="string">'test'</span>, <span class="string">'str'</span>, <span class="string">'END'</span>]</span><br></pre></td></tr></table></figure><p>注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。</p><p>当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = <span class="string">' 123'</span></span><br><span class="line">&gt;&gt;&gt; a.strip()</span><br><span class="line"><span class="string">'123'</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a = <span class="string">'\t\t123\r\n'</span></span><br><span class="line">&gt;&gt;&gt; a.strip()</span><br><span class="line"><span class="string">'123'</span></span><br></pre></td></tr></table></figure><h3 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h3><p>reduce() 函数会对参数序列中元素进行累积。</p><p>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。<br>reduce() 函数在 python 2 是内置函数， 从python 3 开始移到了 functools 模块。<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">求每个单词出现的次数：</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">str = <span class="string">"an apple a banana three apple a desk"</span></span><br><span class="line">list = str.split(<span class="string">' '</span>)</span><br><span class="line">print(list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fun(x, y):</span><br><span class="line">    <span class="keyword">if</span> y <span class="keyword">in</span> x:</span><br><span class="line">        x[y] = x[y] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x[y] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = reduce(fun, list, &#123;&#125;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>格式：<br>lambda arg1,arg2,…..argn:expression</p><p>#冒号:之前的arg1，arg2…表示它们是这个函数的参数。</p><p>#匿名函数不需要return来返回值，表达式本身结果就是返回值。<br>1 匿名函数即没有绑定名字的函数，没有绑定名字，意味着只能用一次就会被回收。<br>2 所以说匿名函数的应用场景就是：某个功能只用一次就结束了。<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = "this is\na\ttest" #建此字符串按照正常情形输出</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line"><span class="string">'this is\na\ttest'</span></span><br><span class="line">&gt;&gt;&gt; print s.split() #split函数默认分割:空格，换行符，TAB</span><br><span class="line">[<span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'a'</span>, <span class="string">'test'</span>]</span><br><span class="line">&gt;&gt;&gt; ' '.join(s.split()) #用join函数转一个列表为字符串</span><br><span class="line"><span class="string">'this is a test'</span></span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; (lambda s:<span class="string">' '</span>.join(s.split()))(<span class="string">"this is\na\ttest"</span>)</span><br></pre></td></tr></table></figure><p>无参数的匿名函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = lambda : True #分号前无任何参数</span><br><span class="line">&gt;&gt;&gt; t()</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">等价于下面的def定义的函数</span><br><span class="line">&gt;&gt;&gt; def func(): <span class="keyword">return</span> True</span><br><span class="line">&gt;&gt;&gt; func()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p> 和map及list联合使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> sys</span><br><span class="line">&gt;&gt;&gt; showall = lambda x:list(map(sys.stdout.write,x))</span><br><span class="line">&gt;&gt;&gt; showall([<span class="string">'Jerry\n'</span>,<span class="string">'Sherry\n'</span>,<span class="string">'Alice\n'</span>])</span><br><span class="line">Jerry</span><br><span class="line">Sherry</span><br><span class="line">Alice</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; showall([<span class="string">'Jerry'</span>,<span class="string">'Sherry'</span>,<span class="string">'Alice'</span>])</span><br><span class="line">JerrySherryAlice</span><br><span class="line"></span><br><span class="line">等价于下面</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; showall = lambda x: [sys.stdout.write(line) <span class="keyword">for</span> line <span class="keyword">in</span> x]</span><br><span class="line">&gt;&gt;&gt; showall((<span class="string">'I\t'</span>,<span class="string">'Love\t'</span>,<span class="string">'You!'</span>))</span><br><span class="line">I Love You![None, None, None]</span><br></pre></td></tr></table></figure><p>求2-50之间的素数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#素数:只能被1或被自己整除的数</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; nums = range(<span class="number">2</span>,<span class="number">50</span>)</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">nums = filter(lambda x:x==i or x % i,nums)</span><br><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>]</span><br></pre></td></tr></table></figure><p>求字符串每个单词的长度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sentence = <span class="string">"Welcome To Beijing!"</span></span><br><span class="line">&gt;&gt;&gt; words = sentence.split()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; lengths = map(lambda x:len(x),words)</span><br><span class="line">&gt;&gt;&gt; lengths</span><br><span class="line">[<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;列表生成式&quot;&gt;&lt;a href=&quot;#列表生成式&quot; class=&quot;headerlink&quot; title=&quot;列表生成式&quot;&gt;&lt;/a&gt;列表生成式&lt;/h3&gt;&lt;p&gt;[x * x for x in range(1, 11)] 就是一个列表生成式, 它的基础语法是:&lt;br&gt;[exp 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单例模式和工厂模式</title>
    <link href="http://ghost-guest@github.io/2018/09/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ghost-guest@github.io/2018/09/07/单例模式和工厂模式/</id>
    <published>2018-09-07T12:38:12.000Z</published>
    <updated>2018-09-08T13:03:00.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是一中常见的软件设计模式 ，该模式的主要目的是确保某个类只有一个实例存在。可以减少内存资源的浪费。</p><h3 id="在python中实现单例的方法"><a href="#在python中实现单例的方法" class="headerlink" title="在python中实现单例的方法"></a>在python中实现单例的方法</h3><p>1.使用模块<br>2.使用<strong>new</strong><br>3.使用装饰器（decorator）<br>4.使用元类（metaclass）</p><h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mysingleton.py</span><br><span class="line">class My_Singleton(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        pass</span><br><span class="line"> </span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure><p>将上面的代码放到mysingleton.py中，然后这样使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"> </span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure><h3 id="使用new"><a href="#使用new" class="headerlink" title="使用new"></a>使用<strong>new</strong></h3><p>为了使类只能出现一个实例，我们可以使用 <strong>new</strong> 来控制实例的创建过程，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    __instance = None</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        <span class="keyword">if</span> not cls._instance:</span><br><span class="line">            cls.__instance = <span class="keyword">super</span>(Singleton, cls).__new__(cls, *args, **kw)  </span><br><span class="line">        <span class="keyword">return</span> cls.__instance  </span><br><span class="line"> </span><br><span class="line">class MyClass(Singleton):  </span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，如果 cls._instance 为 None 则创建实例，否则直接返回 cls._instance。<br>执行情况如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; one = MyClass()</span><br><span class="line">&gt;&gt;&gt; two = MyClass()</span><br><span class="line">&gt;&gt;&gt; one == two</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; one is two</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; id(one), id(two)</span><br><span class="line">(<span class="number">4303862608</span>, <span class="number">4303862608</span>)</span><br></pre></td></tr></table></figure><h3 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h3><p>我们知道，装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line">def singleton(cls):</span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    @wraps(cls)</span><br><span class="line">    def getinstance(*args, **kw):</span><br><span class="line">        <span class="keyword">if</span> cls not <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"> </span><br><span class="line">@singleton</span><br><span class="line">class MyClass(object):</span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，cls(*args, **kw) 作为 value 存到 instances 中，否则，直接返回 instances[cls]。</p><h3 id="使用metaclass"><a href="#使用metaclass" class="headerlink" title="使用metaclass"></a>使用metaclass</h3><p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p><ul><li>拦截类的创建</li><li>修改类的定义</li><li>返回修改后的类<br>使用元类实现单例模式的代码如下：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Singleton(type):</span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        <span class="keyword">if</span> cls not <span class="keyword">in</span> cls._instances:</span><br><span class="line">            cls._instances[cls] = <span class="keyword">super</span>(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"> </span><br><span class="line"># Python2</span><br><span class="line">class MyClass(object):</span><br><span class="line">    __metaclass__ = Singleton</span><br><span class="line"> </span><br><span class="line"># Python3</span><br><span class="line"># class MyClass(metaclass=Singleton):</span><br><span class="line">#    pass</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python 的模块是天然的单例模式，这在大部分情况下应该是够用的，当然，我们也可以使用装饰器、元类等方法</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式是一个在软件开发中用来创建对象的设计模式。</p><p>工厂模式包涵一个超类。这个超类提供一个抽象化的接口来创建一个特定类型的对象，而不是决定哪个对象可以被创建。</p><p>为了实现此方法，需要创建一个工厂类创建并返回。 </p><p>当程序运行输入一个“类型”的时候，需要创建于此相应的对象。这就用到了工厂模式。在如此情形中，实现代码基于工厂模式，可以达到可扩展，可维护的代码。当增加一个新的类型，不在需要修改已存在的类，只增加能够产生新类型的子类。</p><p>简短的说，当以下情形可以使用工厂模式：</p><p>1.不知道用户想要创建什么样的对象</p><p>2.当你想要创建一个可扩展的关联在创建类与支持创建对象的类之间。<br>需求：有一个学雷锋活动，有买米和扫地两个内容，参与的人有大学生和社区志愿者，他们各自的方法不一样。</p><p>如果用简单工厂模式实现:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line"># factory.py 工厂方法设计模式</span><br><span class="line"># 根据传入参数的不同, 而返回对应的对象</span><br><span class="line"># 案例:你去一家餐厅,给厨子'番茄'和'鸡蛋',厨子返回给你'番茄炒鸡蛋';给厨子'白糖'和'黄瓜',厨子返回给你'白糖拌黄瓜'</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class TomatoesAndEgg:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data = <span class="string">"男士喜欢吃番茄炒蛋"</span></span><br><span class="line"> </span><br><span class="line">    def getData(self):</span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class SugarAndCucumber:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data = <span class="number">123456</span></span><br><span class="line"> </span><br><span class="line">    def getData(self):</span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 工厂方法: 根据传入参数的不同, 而返回对应的对象</span><br><span class="line">def cook_factory(sex):</span><br><span class="line">    <span class="keyword">if</span> sex == <span class="string">"man"</span>:</span><br><span class="line">        food = TomatoesAndEgg</span><br><span class="line">    elif sex == <span class="string">"woman"</span>:</span><br><span class="line">        food = SugarAndCucumber</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        raise ValueError(<span class="string">"请出入正确的性别: &#123;&#125;"</span>.format(sex))</span><br><span class="line">    <span class="keyword">return</span> food()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    man = cook_factory(<span class="string">"man"</span>)</span><br><span class="line">    woman = cook_factory(<span class="string">"woman"</span>)</span><br><span class="line"> </span><br><span class="line">    data_man = man.getData()  # 返回String类型数据</span><br><span class="line">    data_woman = woman.getData()  # 返回int类型数据</span><br><span class="line">    # getData()返回不同类型的数据, 这在实际开发中是很常见的</span><br><span class="line"> </span><br><span class="line">    print(data_man)  # =&gt; 男士喜欢吃番茄炒蛋</span><br><span class="line">    print(data_woman)  # =&gt; 123456</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;p&gt;单例模式是一中常见的软件设计模式 ，该模式的主要目的是确保某个类只有一个实例存在。可以减少内存资源的浪费。&lt;/p&gt;
&lt;h3 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FastDFS</title>
    <link href="http://ghost-guest@github.io/2018/09/06/FastDFS/"/>
    <id>http://ghost-guest@github.io/2018/09/06/FastDFS/</id>
    <published>2018-09-06T13:09:52.000Z</published>
    <updated>2018-09-06T13:45:44.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是FastFDS"><a href="#什么是FastFDS" class="headerlink" title="什么是FastFDS"></a>什么是FastFDS</h3><p>FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。<br>FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文 件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。</p><ul><li>Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些 策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。</li><li><p>Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上， Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将 storage 称为存储服务器。</p></li><li><p>Tracker: 管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。</p></li><li>Storage: 实际保存文件， Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是FastFDS&quot;&gt;&lt;a href=&quot;#什么是FastFDS&quot; class=&quot;headerlink&quot; title=&quot;什么是FastFDS&quot;&gt;&lt;/a&gt;什么是FastFDS&lt;/h3&gt;&lt;p&gt;FastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Celery</title>
    <link href="http://ghost-guest@github.io/2018/09/06/Celery/"/>
    <id>http://ghost-guest@github.io/2018/09/06/Celery/</id>
    <published>2018-09-06T11:50:12.000Z</published>
    <updated>2018-09-06T13:08:36.803Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Celery介绍"><a href="#Celery介绍" class="headerlink" title="Celery介绍"></a>Celery介绍</h3><p>1.Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理。用于解决程序中耗时的任务。<br>2.优点：简单，高可用，快速，灵活<br>3.Celery安装和使用：Celery默认brober是Rabbit MQ，可以改为Redis数据库，只需要配置：brober_url=’redis://127.0.0.1:6379/14’<br>4.项目中异步的执行函数main.py</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> . import config</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"># 设置django的配置</span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"meiduo.settings"</span>)</span><br><span class="line"># 创建对象</span><br><span class="line">app = Celery(<span class="string">'meiduo'</span>)</span><br><span class="line"># 加载配置</span><br><span class="line">app.config_from_object(config)</span><br><span class="line"># 初始化任务</span><br><span class="line"># 在指定的包中找到tasks.py 文件，在这个文件中找@app.task的函数</span><br><span class="line">app.autodiscover_tasks([</span><br><span class="line">    <span class="string">'celery_tasks.sms'</span>,</span><br><span class="line">    <span class="string">'celery_tasks.email'</span>,</span><br><span class="line">    <span class="string">'celery_tasks.html'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><ol start="5"><li>在异步包中添加需要执行异步的任务tasks</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.ytx_sdk.sendSMS <span class="keyword">import</span> CCP</span><br><span class="line"><span class="keyword">from</span> celery_tasks.main <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line">@app.task(name=<span class="string">'sms_send'</span>)</span><br><span class="line">def sms_send(mobile, sms_code, expires, template_id):</span><br><span class="line">    # CCP.sendTemplateSMS(mobile, sms_code, expires, template_id)</span><br><span class="line">    print(sms_code)</span><br></pre></td></tr></table></figure><p>6.在需要的视图中执行异步任务：<br>异步对象名.delay(任务所需参数）——–调用异步任务<br>7.启动celery服务<br>celery -A celery_tasks.main worker -l info<br>8.celery构架组成：<br>中间代理人：brober<br>任务执行单元worker，也叫职程<br>执行结果存储backend</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Celery介绍&quot;&gt;&lt;a href=&quot;#Celery介绍&quot; class=&quot;headerlink&quot; title=&quot;Celery介绍&quot;&gt;&lt;/a&gt;Celery介绍&lt;/h3&gt;&lt;p&gt;1.Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Restful风格</title>
    <link href="http://ghost-guest@github.io/2018/09/06/Restful%E9%A3%8E%E6%A0%BC/"/>
    <id>http://ghost-guest@github.io/2018/09/06/Restful风格/</id>
    <published>2018-09-06T11:12:16.000Z</published>
    <updated>2018-09-06T11:47:56.030Z</updated>
    
    <content type="html"><![CDATA[<p>Rest即Representational State Transfer ,直译为‘表现层状态转化’，最大的几个特点是：资源， 统一接口，URI和无状态。</p><h3 id="Restful风格特点"><a href="#Restful风格特点" class="headerlink" title="Restful风格特点"></a>Restful风格特点</h3><p>1.资源：以json(或其他Representation)为载体的、面向用户的一组数据集。<br>2.统一接口：Restful规定数据的操作，增删改查分别对应着Http方法，GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。<br>即：<br>GET（SELECT）：从服务器取出资源（一项或多项）。<br>POST（CREATE）：在服务器新建一个资源。<br>PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。<br>PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。<br>DELETE（DELETE）：从服务器删除资源。</p><ol start="3"><li>URI<br>可以用一个URI（统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。</li><li>无状态<br>所谓无状态的，即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。因为Restful风格是无状态的，所以认证机制就尤为重要，常用的认证机制有：Basic auth，token auth和OAuth。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Rest即Representational State Transfer ,直译为‘表现层状态转化’，最大的几个特点是：资源， 统一接口，URI和无状态。&lt;/p&gt;
&lt;h3 id=&quot;Restful风格特点&quot;&gt;&lt;a href=&quot;#Restful风格特点&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Restful风格" scheme="http://ghost-guest@github.io/tags/Restful%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>MVT与MCV</title>
    <link href="http://ghost-guest@github.io/2018/09/06/MVT%E4%B8%8EMCV/"/>
    <id>http://ghost-guest@github.io/2018/09/06/MVT与MCV/</id>
    <published>2018-09-06T08:55:13.000Z</published>
    <updated>2018-09-06T09:11:43.218Z</updated>
    
    <content type="html"><![CDATA[<p>MVC的核心思想：解耦，让不同的代码之间降低耦合，增强代码的可移植性和可扩展性，实现向后兼容。</p><h3 id="Web-MVC各部分的功能："><a href="#Web-MVC各部分的功能：" class="headerlink" title="Web MVC各部分的功能："></a>Web MVC各部分的功能：</h3><p>1.Model：主要封装了对数据库层的的访问，对数据库中的数据进行增，删，改，查操作。<br>2.View：用于封装结果，生成页面html内容与用户进行交互。<br>3.Controller：用于接受请求，处理业务逻辑，与Model和View交互，返回结果。</p><p>MVT： Django 遵循MVC设计，并有一个专有名词：MVT</p><h3 id="MVT各部分的功能"><a href="#MVT各部分的功能" class="headerlink" title="MVT各部分的功能"></a>MVT各部分的功能</h3><p>1.Model： 负责与数据库交互，进行数据操作。<br>2.View：与MVC中的C的功能一样，接受请求，处理业务，返回应答。<br>3.Template： 与MVC中的V的功能一样，负责封装要返回的html。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MVC的核心思想：解耦，让不同的代码之间降低耦合，增强代码的可移植性和可扩展性，实现向后兼容。&lt;/p&gt;
&lt;h3 id=&quot;Web-MVC各部分的功能：&quot;&gt;&lt;a href=&quot;#Web-MVC各部分的功能：&quot; class=&quot;headerlink&quot; title=&quot;Web MVC各部
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python的PEP8规范</title>
    <link href="http://ghost-guest@github.io/2018/09/06/PEP8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://ghost-guest@github.io/2018/09/06/PEP8编码规范/</id>
    <published>2018-09-06T07:50:35.000Z</published>
    <updated>2018-09-06T11:13:00.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PEP8-Python-编码规范"><a href="#PEP8-Python-编码规范" class="headerlink" title="PEP8 Python 编码规范"></a>PEP8 Python 编码规范</h2><h3 id="代码编程"><a href="#代码编程" class="headerlink" title="代码编程"></a>代码编程</h3><ol><li>缩进，4个空格的缩进，不使用Tab，更不能混合使用Tab和空格。</li><li>每行最大长度79，换行可以使用反斜杠，最好使用圆括号。</li><li>类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。</li></ol><h3 id="文档编排"><a href="#文档编排" class="headerlink" title="文档编排"></a>文档编排</h3><p>1.模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。<br>2.不要在一句import中多个库，比如import os, sys不推荐。<br>3.如果采用from XX import XX引用库，可以省略‘module.’，都是可能出现命名冲突，这时就要采用import XX。</p><h3 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h3><pre><code>总体原则，避免不必要的空格。</code></pre><p>1 各种右括号前不要加空格。<br>2 逗号、冒号、分号前不要加空格。<br>3 函数的左括号前不要加空格。如Func(1)。<br>4 序列的左括号前不要加空格。如list[2]。<br>5 操作符左右各加一个空格，不要为了对齐增加空格。<br>6 函数默认参数使用的赋值符左右省略空格。<br>7 不要将多句语句写在同一行，尽管使用‘；’允许。<br>8 if/for/while语句中，即使执行语句只有一句，也必须另起一行。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>  总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！<br>        注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。</p><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><pre><code>总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。</code></pre><p>1 尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。<br>2 模块命名尽量短小，使用全部小写的方式，可以使用下划线。<br>3 包命名尽量短小，使用全部小写的方式，不可以使用下划线。<br>4 类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。<br>5 异常命名使用CapWords+Error后缀的方式。<br>6 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是<strong>all</strong>机制;二是前缀一个下划线。<br>7 函数命名使用全部小写的方式，可以使用下划线。<br>8 常量命名使用全部大写的方式，可以使用下划线。<br>9 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。<br>9 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。<br>11 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。<br>12 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明<strong>a,访问时，只能通过Foo._Foo</strong>a，避免歧义。如果子类也叫Foo，那就无能为力了。<br>13 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。</p><h4 id="编码建议"><a href="#编码建议" class="headerlink" title="编码建议"></a>编码建议</h4><p>1 编码中考虑到其他python实现的效率等问题，比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。<br>2 尽可能使用‘is’‘is not’取代‘==’，比如if x is not None 要优于if x。<br>3 使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自Exception。<br>4 异常中不要使用裸露的except，except后跟具体的exceptions。<br>5 异常中try的代码尽可能少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PEP8-Python-编码规范&quot;&gt;&lt;a href=&quot;#PEP8-Python-编码规范&quot; class=&quot;headerlink&quot; title=&quot;PEP8 Python 编码规范&quot;&gt;&lt;/a&gt;PEP8 Python 编码规范&lt;/h2&gt;&lt;h3 id=&quot;代码编程&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="PEP8规范" scheme="http://ghost-guest@github.io/tags/PEP8%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://ghost-guest@github.io/2018/09/03/hello-world/"/>
    <id>http://ghost-guest@github.io/2018/09/03/hello-world/</id>
    <published>2018-09-03T13:08:57.245Z</published>
    <updated>2018-09-03T13:08:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
