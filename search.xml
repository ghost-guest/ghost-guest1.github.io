<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[itsdangerous]]></title>
    <url>%2F2018%2F09%2F11%2Fitsdangerous%2F</url>
    <content type="text"><![CDATA[itsdangerous介绍有时候你想向不可信的环境发送一些数据，但如何安全完成这个任务呢？解决的方法就是签名。使用只有你自己知道的密钥，来加密签名你的数据，并把加密后的数据发给别人。当你取回数据时，你就可以确保没人篡改过这份数据。诚然，接收者可以破译内容，来看看你的包裹里有什么，但他们没办法修改你的内容，除非他们也有你的密钥。所以只要你保管好你的密钥，并且密钥足够复杂，一切就OK了。itsdangerous内部默认使用了HMAC和SHA1来签名，基于 Django 签名模块。它也支持JSON Web 签名 (JWS)。这个库采用BSD协议，由Armin Ronacher编写，而大部分设计与实现的版权归Simon Willison和其他的把这个库变为现实的Django爱好者们。itsdangerous中dumps和loads： json，pickle, itsdangerous中的loads、dumps 的对比分析1.json中的json.dumps和json.loads: json.dumps(): 将一个Python数据类型进行json格式的编码解析(dict转成str) json.loads():将json格式的基于字典的字符串转换成Python数据类型（str转成dict） 扩展：json.loads和json.load，json.dumps和json.dump的区别 json.dump是将python数据保存成json。主要配合json.load来使用。 json.dump(x,f)，x是对象，f是文件对象，将json数据写入到f文本文件当中。 json.load是读取json数据 。主要配合json.dump来使用. 2. pickle中的pickle.dumps和pickle.loads：pickle.dumps():将obj对象序列化并返回一个bytes对象(某一个数据类型转成bytes). pickle.loads():将bytes反序列化并返回一个对象(bytes转成之前的数据类型). ![enter description here](./images/1536653827776.png) 扩展：pickle.loads和pickle.load，pickle.dumps和pickle.dump的区别 pickle.dump()方法将obj对象序列化为字节（bytes）写入到file文件中pickle.load()从一个对象文件中读取序列化数据，将其反序列化之后返回一个对象. 3.json-pickle-itsdangerous对比总结:1-pickle不是用于多种语言间的数据传输，它仅作为python对象的持久化，只针对python的数据类型；而json可以支持更多语言的序列化和反序列化，在python中序列化一个自定义的类对象时，会抛出一个 TypeError;2-json的序列化输出是文本对象是str类型，而pickle序列化的输出是二进制字节-bytes 3-json可读性优于pickle。 4-itsdangerous也提供了一个与json或pickle类似的序列化接口。（它内部默认使用simplejson，但是可以通过子类进行修改） 5-pickle:就是将python数据转成原始的二进制数据； itsdangerous:就是通过密钥secret-key进行加密处理。多用于生成token。 4.jsonify和json.dumps()sonify的作用实际上就是将我们传入的json形式数据序列化成为json字符串，作为响应的body，并且设置响应的Content-Type为application/json，构造出响应返回至客户端。jsonify的部分源码如下：jsonify将dict类型转变为json对象。json.dumps只是将dict类型转化为str类型，并非一个json对象。jsonify其实也是用dumps方法转换成了json格式的字符串，但是jsonify会根据http协议的body进行格式重新编排。而json.dumps只是单纯的将dict类型转化为str类型，可以直接return json.dumps(data)。]]></content>
  </entry>
  <entry>
    <title><![CDATA[python三大神器]]></title>
    <url>%2F2018%2F09%2F10%2Fpython%E4%B8%89%E5%A4%A7%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[python三大神器装饰器、生成器、迭代器 装饰器在说装饰器之前先了解一下闭包函数： 12345678910111213141516# 外函数outer()def outer(): # 外函数局部变量，对于内函数来说相当于全局变量 number = 10 # 内函数 def inner(): # 外函数数据的引用 nonlocal number number += 1 # 返回值是内函数inner的引用 return inner # 调用outer函数，用func接收inner函数的引用func = outer()# 调用inner函数 func() 在一个函数里边定义了一个函数 内函数可能会用到外函数的数据 外函数一定有返回值，而且是内函数的引用 装饰器的定义闭包的延伸，外函数传入函数的引用，而且内函数返回函数的调用就是装饰器。 装饰器的作用在不修改函数体的前提下，在函数前面添加功能比如验证等 。 原理直接调用内函数，先执行内函数函数体，即验证的部分，在内函数的返回值的地方返回传入函数的调用，即不被修改的函数体。 12345678910def outer(func): def inner(): return func() return inner# 装饰器的使用 @ ：相当于 func = outer(func) # 即把func的引用替换成outer的返回值，也就是内函数的引用# 然后在内函数中返回原本func的引用的调用，即func的函数体@outerdef func(): pass 内置装饰器python中内置的装饰器有三个：staticmethod、classmethod和property，作用分别是把类中定义的实例方法变成静态方法、类方法和类属性。functools模块提供了两个装饰器：1.wraps(wrapped[, assigned][, updated]):这是一个很有用的装饰器。看过前一篇反射的朋友应该知道，函数是有几个特殊属性比如函数名，在被装饰后，上例中的函数名foo会变成包装函数的名字wrapper，如果你希望使用反射，可能会导致意外的结果。这个装饰器可以解决这个问题，它能将装饰过的函数的特殊属性保留。 12345678910111213141516171819import time import functools def timeit(func): @functools.wraps(func) def wrapper(): start = time.clock() func() end =time.clock() print ‘used:’, end - start return wrapper@timeitdef foo(): print ‘in foo()’foo()print foo.__name__ 首先注意第5行，如果注释这一行，foo.name将是’wrapper’。另外相信你也注意到了，这个装饰器竟然带有一个参数。实际上，他还有另外两个可选的参数，assigned中的属性名将使用赋值的方式替换，而updated中的属性名将使用update的方式合并，你可以通过查看functools的源代码获得它们的默认值。对于这个装饰器，相当于wrapper = functools.wraps(func)(wrapper)。2.total_ordering(cls):这个装饰器在特定的场合有一定用处，但是它是在Python 2.7后新增的。它的作用是为实现了至少lt、le、gt、ge其中一个的类加上其他的比较方法，这是一个类装饰器。如果觉得不好理解，不妨仔细看看这个装饰器的源代码： 1234567891011121314151617181920212223242526def total_ordering(cls): """Class decorator that fills in missing ordering methods""" convert = &#123; '__lt__': [('__gt__', lambda self, other: other &lt; self), ('__le__', lambda self, other: not other &lt; self), ('__ge__', lambda self, other: not self &lt; other)], '__le__': [('__ge__', lambda self, other: other &lt;= self), ('__lt__', lambda self, other: not other &lt;= self), ('__gt__', lambda self, other: not self &lt;= other)], '__gt__': [('__lt__', lambda self, other: other &gt; self), ('__ge__', lambda self, other: not other &gt; self), ('__le__', lambda self, other: not self &gt; other)], '__ge__': [('__le__', lambda self, other: other &gt;= self), ('__gt__', lambda self, other: not other &gt;= self), ('__lt__', lambda self, other: not self &gt;= other)] &#125; roots = set(dir(cls)) &amp; set(convert) if not roots: raise ValueError('must define at least one ordering operation: &lt; &gt; &lt;= &gt;=') root = max(roots) # prefer __lt__ to __le__ to __gt__ to __ge__ for opname, opfunc in convert[root]: if opname not in roots: opfunc.__name__ = opname opfunc.__doc__ = getattr(int, opname).__doc__ setattr(cls, opname, opfunc) return cls 进阶装饰器1.带有参数的装饰器：假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出log信息，而且还需指定log的级别，那么装饰器就会是这样的。 123456789101112131415161718192021222324def logging(level): def wrapper(func): def inner_wrapper(*args, **kwargs): print "[&#123;level&#125;]: enter function &#123;func&#125;()".format( level=level, func=func.__name__) return func(*args, **kwargs) return inner_wrapper return wrapper@logging(level='INFO')def say(something): print "say &#123;&#125;!".format(something)# 如果没有使用@语法，等同于# say = logging(level='INFO')(say)@logging(level='DEBUG')def do(something): print "do &#123;&#125;...".format(something)if __name__ == '__main__': say('hello') do("my work") 当带参数的装饰器被打在某个函数上时，比如@logging(level=’DEBUG’)，它其实是一个函数，会马上被执行，只要这个它返回的结果是一个装饰器时，那就没问题。细细再体会一下。2.基于类实现的装饰器装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了call()方法，那么这个对象就是callable的。用类来实现也是也可以的。我们可以让类的构造函数init()接受一个函数，然后重载call()并返回一个函数，也可以达到装饰器函数的效果。 1234567891011class logging(object): def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): print "[DEBUG]: enter function &#123;func&#125;()".format( func=self.func.__name__) return self.func(*args, **kwargs)@loggingdef say(something): print "say &#123;&#125;!".format(something) 3.带有参数的类装饰器如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接受的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载call方法是就需要接受一个函数并返回一个函数。 123456789101112131415class logging(object): def __init__(self, level='INFO'): self.level = level def __call__(self, func): # 接受函数 def wrapper(*args, **kwargs): print "[&#123;level&#125;]: enter function &#123;func&#125;()".format( level=self.level, func=func.__name__) func(*args, **kwargs) return wrapper #返回函数@logging(level='INFO')def say(something): print "say &#123;&#125;!".format(something) 迭代器迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退，不过这也没什么，因为人们很少在迭代途中往后退。另外，迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件。 特点a）访问者不需要关心迭代器内部的结构，仅需通过next()方法或不断去取下一个内容 b）不能随机访问集合中的某个值 ，只能从头到尾依次访问 c）访问到一半时不能往回退 d）便于循环比较大的数据集合，节省内存 e）也不能复制一个迭代器。如果要再次（或者同时）迭代同一个对象，只能去创建另一个迭代器对象。enumerate()的返回值就是一个迭代器。 可迭代对象和可迭代器可以直接作用于for循环的对象统称为可迭代对象(Iterable)。 可以被next()函数调用并不断返回下一个值的对象称为迭代器(Iterator)。 所有的Iterable均可以通过内置函数iter()来转变为Iterator。如何判断一个对象是可迭代对象呢？可以通过collections模块的Iterable类型判断。可迭代对象：迭代器是一个对象，不是一个函数；是一个什么样的对象呢？就是只要它定义了可以返回一个迭代器的iter方法，或者定义了可以支持下标索引的getitem方法，那么它就是一个可迭代对象。迭代器：任何实现了iter和next()（python2中实现next()）方法的对象都是迭代器，iter返回迭代器自身，next返回容器中的下一个值。 生成器理解了迭代器以后，生成器就会简单很多，因为生成器其实是一种特殊的迭代器。不过这种迭代器更加优雅。它不需要再像上面的类一样写iter()和next()方法了，只需要一个yiled关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。语法上说，生成器函数是一个带yield关键字的函数。调用生成器函数后会得到一个生成器对象，这个生成器对象实际上就是一个特殊的迭代器，拥有iter()和next()方法。小结：按照鸭子模型理论，生成器就是一种迭代器，可以使用for进行迭代。 第一次执行next(generator)时，会执行完yield语句后程序进行挂起，所有的参数和状态会进行保存。再一次执行next(generator)时，会从挂起的状态开始往后执行。在遇到程序的结尾或者遇到StopIteration时，循环结束。 可以通过generator.send(arg)来传入参数，这是协程模型。 可以通过generator.throw(exception)来传入一个异常。throw语句会消耗掉一个yield。可以通过generator.close()来手动关闭生成器。 next()等价于send(None)]]></content>
  </entry>
  <entry>
    <title><![CDATA[列表生成式与匿名函数]]></title>
    <url>%2F2018%2F09%2F08%2F%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[列表生成式[x * x for x in range(1, 11)] 就是一个列表生成式, 它的基础语法是:[exp for iter_var in iterable]首先迭代 iterable 里所有内容, 每一次迭代, 都把 iterable 里相应内容放到 iter_var 中, 再在表达式 exp 中应用该 iter_var 的内容, 最后用表达式的计算值生成一个新的列表.例如, 把一个 list 中所有的字符串变成小写: 123L = ['Hello', 'World', 'IBM', 'Apple'][s.lower() for s in L]&gt;&gt;&gt; ['hello', 'world', 'ibm', 'apple'] map（）函数map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。例子： 12345678910111213141516171819202122a = [1, 2, 3, 4]b = [x + 1 for x in a]print(b)c = [x for x in map(lambda x, y: x + y, a, b)]print(c)# d = [x for x in c]# print(d)l4 = map(lambda x, y: (x ** y, x + y), [1, 2, 3], [1, 2])for i in l4: print(i)# l4 = map(lambda x, y: (x ** y, x + y), [1, 2, 3], [1, 2, 'a'])# for i in l4:# print(i)l = [1, 2, 3]x = map(None, l)print(x)结果：[2, 3, 4, 5][3, 5, 7, 9](1, 2)(4, 4)&lt;map object at 0x00000191E293EE48&gt; filter（）函数filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数： 12def is_odd(x): return x % 2 == 1 然后，利用filter()过滤掉偶数： 12&gt;&gt;&gt;filter(is_odd, [1, 4, 6, 7, 9, 12, 17])&gt;&gt;&gt;[1, 7, 9, 17] 利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串： 1234def is_not_empty(s): return s and len(s.strip()) &gt; 0&gt;&gt;&gt;filter(is_not_empty, ['test', None, '', 'str', ' ', 'END'])&gt;&gt;&gt;['test', 'str', 'END'] 注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。 当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下： 1234567&gt;&gt;&gt; a = ' 123'&gt;&gt;&gt; a.strip()'123'&gt;&gt;&gt; a = '\t\t123\r\n'&gt;&gt;&gt; a.strip()'123' reduce函数reduce() 函数会对参数序列中元素进行累积。 函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。reduce() 函数在 python 2 是内置函数， 从python 3 开始移到了 functools 模块。例子： 123456789101112131415161718求每个单词出现的次数：from functools import reducestr = "an apple a banana three apple a desk"list = str.split(' ')print(list)def fun(x, y): if y in x: x[y] = x[y] + 1 else: x[y] = 1 return xresult = reduce(fun, list, &#123;&#125;)print(result) 匿名函数格式：lambda arg1,arg2,…..argn:expression #冒号:之前的arg1，arg2…表示它们是这个函数的参数。 #匿名函数不需要return来返回值，表达式本身结果就是返回值。1 匿名函数即没有绑定名字的函数，没有绑定名字，意味着只能用一次就会被回收。2 所以说匿名函数的应用场景就是：某个功能只用一次就结束了。例子： 1234567891011&gt;&gt;&gt; s = "this is\na\ttest" #建此字符串按照正常情形输出&gt;&gt;&gt; s'this is\na\ttest'&gt;&gt;&gt; print s.split() #split函数默认分割:空格，换行符，TAB['this', 'is', 'a', 'test']&gt;&gt;&gt; ' '.join(s.split()) #用join函数转一个列表为字符串'this is a test'等价于&gt;&gt;&gt; (lambda s:' '.join(s.split()))("this is\na\ttest") 无参数的匿名函数： 12345678&gt;&gt;&gt; t = lambda : True #分号前无任何参数&gt;&gt;&gt; t()True等价于下面的def定义的函数&gt;&gt;&gt; def func(): return True&gt;&gt;&gt; func()True 和map及list联合使用： 123456789101112131415&gt;&gt;&gt; import sys&gt;&gt;&gt; showall = lambda x:list(map(sys.stdout.write,x))&gt;&gt;&gt; showall(['Jerry\n','Sherry\n','Alice\n'])JerrySherryAlice&gt;&gt;&gt; showall(['Jerry','Sherry','Alice'])JerrySherryAlice等价于下面&gt;&gt;&gt; showall = lambda x: [sys.stdout.write(line) for line in x]&gt;&gt;&gt; showall(('I\t','Love\t','You!'))I Love You![None, None, None] 求2-50之间的素数： 1234567#素数:只能被1或被自己整除的数&gt;&gt;&gt; nums = range(2,50)&gt;&gt;&gt; for i in nums:nums = filter(lambda x:x==i or x % i,nums)&gt;&gt;&gt; nums[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] 求字符串每个单词的长度： 123456&gt;&gt;&gt; sentence = "Welcome To Beijing!"&gt;&gt;&gt; words = sentence.split()&gt;&gt;&gt; lengths = map(lambda x:len(x),words)&gt;&gt;&gt; lengths[7, 2, 8]]]></content>
  </entry>
  <entry>
    <title><![CDATA[单例模式和工厂模式]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式单例模式是一中常见的软件设计模式 ，该模式的主要目的是确保某个类只有一个实例存在。可以减少内存资源的浪费。 在python中实现单例的方法1.使用模块2.使用new3.使用装饰器（decorator）4.使用元类（metaclass） 使用模块其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做： 123456# mysingleton.pyclass My_Singleton(object): def foo(self): pass my_singleton = My_Singleton() 将上面的代码放到mysingleton.py中，然后这样使用： 123from mysingleton import my_singleton my_singleton.foo() 使用new为了使类只能出现一个实例，我们可以使用 new 来控制实例的创建过程，代码如下： 123456789class Singleton(object): __instance = None def __new__(cls, *args, **kw): if not cls._instance: cls.__instance = super(Singleton, cls).__new__(cls, *args, **kw) return cls.__instance class MyClass(Singleton): a = 1 在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，如果 cls._instance 为 None 则创建实例，否则直接返回 cls._instance。执行情况如下： 12345678&gt;&gt;&gt; one = MyClass()&gt;&gt;&gt; two = MyClass()&gt;&gt;&gt; one == twoTrue&gt;&gt;&gt; one is twoTrue&gt;&gt;&gt; id(one), id(two)(4303862608, 4303862608) 使用装饰器我们知道，装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下： 1234567891011121314from functools import wraps def singleton(cls): instances = &#123;&#125; @wraps(cls) def getinstance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance @singletonclass MyClass(object): a = 1 在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，cls(*args, **kw) 作为 value 存到 instances 中，否则，直接返回 instances[cls]。 使用metaclass元类（metaclass）可以控制类的创建过程，它主要做三件事： 拦截类的创建 修改类的定义 返回修改后的类使用元类实现单例模式的代码如下： 123456789101112131415class Singleton(type): _instances = &#123;&#125; def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] # Python2class MyClass(object): __metaclass__ = Singleton # Python3# class MyClass(metaclass=Singleton):# pass 小结Python 的模块是天然的单例模式，这在大部分情况下应该是够用的，当然，我们也可以使用装饰器、元类等方法 工厂模式工厂模式是一个在软件开发中用来创建对象的设计模式。 工厂模式包涵一个超类。这个超类提供一个抽象化的接口来创建一个特定类型的对象，而不是决定哪个对象可以被创建。 为了实现此方法，需要创建一个工厂类创建并返回。 当程序运行输入一个“类型”的时候，需要创建于此相应的对象。这就用到了工厂模式。在如此情形中，实现代码基于工厂模式，可以达到可扩展，可维护的代码。当增加一个新的类型，不在需要修改已存在的类，只增加能够产生新类型的子类。 简短的说，当以下情形可以使用工厂模式： 1.不知道用户想要创建什么样的对象 2.当你想要创建一个可扩展的关联在创建类与支持创建对象的类之间。需求：有一个学雷锋活动，有买米和扫地两个内容，参与的人有大学生和社区志愿者，他们各自的方法不一样。 如果用简单工厂模式实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8# factory.py 工厂方法设计模式# 根据传入参数的不同, 而返回对应的对象# 案例:你去一家餐厅,给厨子'番茄'和'鸡蛋',厨子返回给你'番茄炒鸡蛋';给厨子'白糖'和'黄瓜',厨子返回给你'白糖拌黄瓜' class TomatoesAndEgg: def __init__(self): self.data = "男士喜欢吃番茄炒蛋" def getData(self): return self.data class SugarAndCucumber: def __init__(self): self.data = 123456 def getData(self): return self.data # 工厂方法: 根据传入参数的不同, 而返回对应的对象def cook_factory(sex): if sex == "man": food = TomatoesAndEgg elif sex == "woman": food = SugarAndCucumber else: raise ValueError("请出入正确的性别: &#123;&#125;".format(sex)) return food() if __name__ == "__main__": man = cook_factory("man") woman = cook_factory("woman") data_man = man.getData() # 返回String类型数据 data_woman = woman.getData() # 返回int类型数据 # getData()返回不同类型的数据, 这在实际开发中是很常见的 print(data_man) # =&gt; 男士喜欢吃番茄炒蛋 print(data_woman) # =&gt; 123456]]></content>
  </entry>
  <entry>
    <title><![CDATA[FastDFS]]></title>
    <url>%2F2018%2F09%2F06%2FFastDFS%2F</url>
    <content type="text"><![CDATA[什么是FastFDSFastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文 件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。 Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些 策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。 Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上， Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将 storage 称为存储服务器。 Tracker: 管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。 Storage: 实际保存文件， Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Celery]]></title>
    <url>%2F2018%2F09%2F06%2FCelery%2F</url>
    <content type="text"><![CDATA[Celery介绍1.Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理。用于解决程序中耗时的任务。2.优点：简单，高可用，快速，灵活3.Celery安装和使用：Celery默认brober是Rabbit MQ，可以改为Redis数据库，只需要配置：brober_url=’redis://127.0.0.1:6379/14’4.项目中异步的执行函数main.py 1234567891011121314151617from celery import Celeryfrom . import configimport os# 设置django的配置os.environ.setdefault("DJANGO_SETTINGS_MODULE", "meiduo.settings")# 创建对象app = Celery('meiduo')# 加载配置app.config_from_object(config)# 初始化任务# 在指定的包中找到tasks.py 文件，在这个文件中找@app.task的函数app.autodiscover_tasks([ 'celery_tasks.sms', 'celery_tasks.email', 'celery_tasks.html']) 在异步包中添加需要执行异步的任务tasks 1234567from utils.ytx_sdk.sendSMS import CCPfrom celery_tasks.main import app@app.task(name='sms_send')def sms_send(mobile, sms_code, expires, template_id): # CCP.sendTemplateSMS(mobile, sms_code, expires, template_id) print(sms_code) 6.在需要的视图中执行异步任务：异步对象名.delay(任务所需参数）——–调用异步任务7.启动celery服务celery -A celery_tasks.main worker -l info8.celery构架组成：中间代理人：brober任务执行单元worker，也叫职程执行结果存储backend]]></content>
  </entry>
  <entry>
    <title><![CDATA[Restful风格]]></title>
    <url>%2F2018%2F09%2F06%2FRestful%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[Rest即Representational State Transfer ,直译为‘表现层状态转化’，最大的几个特点是：资源， 统一接口，URI和无状态。 Restful风格特点1.资源：以json(或其他Representation)为载体的、面向用户的一组数据集。2.统一接口：Restful规定数据的操作，增删改查分别对应着Http方法，GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。即：GET（SELECT）：从服务器取出资源（一项或多项）。POST（CREATE）：在服务器新建一个资源。PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。DELETE（DELETE）：从服务器删除资源。 URI可以用一个URI（统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。 无状态所谓无状态的，即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。因为Restful风格是无状态的，所以认证机制就尤为重要，常用的认证机制有：Basic auth，token auth和OAuth。]]></content>
      <tags>
        <tag>Restful风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVT与MCV]]></title>
    <url>%2F2018%2F09%2F06%2FMVT%E4%B8%8EMCV%2F</url>
    <content type="text"><![CDATA[MVC的核心思想：解耦，让不同的代码之间降低耦合，增强代码的可移植性和可扩展性，实现向后兼容。 Web MVC各部分的功能：1.Model：主要封装了对数据库层的的访问，对数据库中的数据进行增，删，改，查操作。2.View：用于封装结果，生成页面html内容与用户进行交互。3.Controller：用于接受请求，处理业务逻辑，与Model和View交互，返回结果。 MVT： Django 遵循MVC设计，并有一个专有名词：MVT MVT各部分的功能1.Model： 负责与数据库交互，进行数据操作。2.View：与MVC中的C的功能一样，接受请求，处理业务，返回应答。3.Template： 与MVC中的V的功能一样，负责封装要返回的html。]]></content>
  </entry>
  <entry>
    <title><![CDATA[python的PEP8规范]]></title>
    <url>%2F2018%2F09%2F06%2FPEP8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[PEP8 Python 编码规范代码编程 缩进，4个空格的缩进，不使用Tab，更不能混合使用Tab和空格。 每行最大长度79，换行可以使用反斜杠，最好使用圆括号。 类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。 文档编排1.模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。2.不要在一句import中多个库，比如import os, sys不推荐。3.如果采用from XX import XX引用库，可以省略‘module.’，都是可能出现命名冲突，这时就要采用import XX。 空格的使用总体原则，避免不必要的空格。 1 各种右括号前不要加空格。2 逗号、冒号、分号前不要加空格。3 函数的左括号前不要加空格。如Func(1)。4 序列的左括号前不要加空格。如list[2]。5 操作符左右各加一个空格，不要为了对齐增加空格。6 函数默认参数使用的赋值符左右省略空格。7 不要将多句语句写在同一行，尽管使用‘；’允许。8 if/for/while语句中，即使执行语句只有一句，也必须另起一行。 注释 总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！ 注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。 命名规范总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。 1 尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。2 模块命名尽量短小，使用全部小写的方式，可以使用下划线。3 包命名尽量短小，使用全部小写的方式，不可以使用下划线。4 类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。5 异常命名使用CapWords+Error后缀的方式。6 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是all机制;二是前缀一个下划线。7 函数命名使用全部小写的方式，可以使用下划线。8 常量命名使用全部大写的方式，可以使用下划线。9 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。9 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。11 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。12 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明a,访问时，只能通过Foo._Fooa，避免歧义。如果子类也叫Foo，那就无能为力了。13 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。 编码建议1 编码中考虑到其他python实现的效率等问题，比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。2 尽可能使用‘is’‘is not’取代‘==’，比如if x is not None 要优于if x。3 使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自Exception。4 异常中不要使用裸露的except，except后跟具体的exceptions。5 异常中try的代码尽可能少。]]></content>
      <tags>
        <tag>PEP8规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
