<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[列表生成式与匿名函数]]></title>
    <url>%2F2018%2F09%2F08%2F%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[列表生成式[x * x for x in range(1, 11)] 就是一个列表生成式, 它的基础语法是:[exp for iter_var in iterable]首先迭代 iterable 里所有内容, 每一次迭代, 都把 iterable 里相应内容放到 iter_var 中, 再在表达式 exp 中应用该 iter_var 的内容, 最后用表达式的计算值生成一个新的列表.例如, 把一个 list 中所有的字符串变成小写: 123L = ['Hello', 'World', 'IBM', 'Apple'][s.lower() for s in L]&gt;&gt;&gt; ['hello', 'world', 'ibm', 'apple'] map（）函数map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。例子： 12345678910111213141516171819202122a = [1, 2, 3, 4]b = [x + 1 for x in a]print(b)c = [x for x in map(lambda x, y: x + y, a, b)]print(c)# d = [x for x in c]# print(d)l4 = map(lambda x, y: (x ** y, x + y), [1, 2, 3], [1, 2])for i in l4: print(i)# l4 = map(lambda x, y: (x ** y, x + y), [1, 2, 3], [1, 2, 'a'])# for i in l4:# print(i)l = [1, 2, 3]x = map(None, l)print(x)结果：[2, 3, 4, 5][3, 5, 7, 9](1, 2)(4, 4)&lt;map object at 0x00000191E293EE48&gt; filter（）函数filter()函数是 Python 内置的另一个有用的高阶函数，filter()函数接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter()根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。例如，要从一个list [1, 4, 6, 7, 9, 12, 17]中删除偶数，保留奇数，首先，要编写一个判断奇数的函数： 12def is_odd(x): return x % 2 == 1 然后，利用filter()过滤掉偶数： 12&gt;&gt;&gt;filter(is_odd, [1, 4, 6, 7, 9, 12, 17])&gt;&gt;&gt;[1, 7, 9, 17] 利用filter()，可以完成很多有用的功能，例如，删除 None 或者空字符串： 1234def is_not_empty(s): return s and len(s.strip()) &gt; 0&gt;&gt;&gt;filter(is_not_empty, ['test', None, '', 'str', ' ', 'END'])&gt;&gt;&gt;['test', 'str', 'END'] 注意: s.strip(rm) 删除 s 字符串中开头、结尾处的 rm 序列的字符。 当rm为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下： 1234567&gt;&gt;&gt; a = ' 123'&gt;&gt;&gt; a.strip()'123'&gt;&gt;&gt; a = '\t\t123\r\n'&gt;&gt;&gt; a.strip()'123']]></content>
  </entry>
  <entry>
    <title><![CDATA[单例模式和工厂模式]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式单例模式是一中常见的软件设计模式 ，该模式的主要目的是确保某个类只有一个实例存在。可以减少内存资源的浪费。 在python中实现单例的方法1.使用模块2.使用new3.使用装饰器（decorator）4.使用元类（metaclass） 使用模块其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做： 123456# mysingleton.pyclass My_Singleton(object): def foo(self): pass my_singleton = My_Singleton() 将上面的代码放到mysingleton.py中，然后这样使用： 123from mysingleton import my_singleton my_singleton.foo() 使用new为了使类只能出现一个实例，我们可以使用 new 来控制实例的创建过程，代码如下： 123456789class Singleton(object): __instance = None def __new__(cls, *args, **kw): if not cls._instance: cls.__instance = super(Singleton, cls).__new__(cls, *args, **kw) return cls.__instance class MyClass(Singleton): a = 1 在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，如果 cls._instance 为 None 则创建实例，否则直接返回 cls._instance。执行情况如下： 12345678&gt;&gt;&gt; one = MyClass()&gt;&gt;&gt; two = MyClass()&gt;&gt;&gt; one == twoTrue&gt;&gt;&gt; one is twoTrue&gt;&gt;&gt; id(one), id(two)(4303862608, 4303862608) 使用装饰器我们知道，装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下： 1234567891011121314from functools import wraps def singleton(cls): instances = &#123;&#125; @wraps(cls) def getinstance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance @singletonclass MyClass(object): a = 1 在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，cls(*args, **kw) 作为 value 存到 instances 中，否则，直接返回 instances[cls]。 使用metaclass元类（metaclass）可以控制类的创建过程，它主要做三件事： 拦截类的创建 修改类的定义 返回修改后的类使用元类实现单例模式的代码如下： 123456789101112131415class Singleton(type): _instances = &#123;&#125; def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] # Python2class MyClass(object): __metaclass__ = Singleton # Python3# class MyClass(metaclass=Singleton):# pass 小结Python 的模块是天然的单例模式，这在大部分情况下应该是够用的，当然，我们也可以使用装饰器、元类等方法 工厂模式工厂模式是一个在软件开发中用来创建对象的设计模式。 工厂模式包涵一个超类。这个超类提供一个抽象化的接口来创建一个特定类型的对象，而不是决定哪个对象可以被创建。 为了实现此方法，需要创建一个工厂类创建并返回。 当程序运行输入一个“类型”的时候，需要创建于此相应的对象。这就用到了工厂模式。在如此情形中，实现代码基于工厂模式，可以达到可扩展，可维护的代码。当增加一个新的类型，不在需要修改已存在的类，只增加能够产生新类型的子类。 简短的说，当以下情形可以使用工厂模式： 1.不知道用户想要创建什么样的对象 2.当你想要创建一个可扩展的关联在创建类与支持创建对象的类之间。需求：有一个学雷锋活动，有买米和扫地两个内容，参与的人有大学生和社区志愿者，他们各自的方法不一样。 如果用简单工厂模式实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243# coding=utf-8# factory.py 工厂方法设计模式# 根据传入参数的不同, 而返回对应的对象# 案例:你去一家餐厅,给厨子'番茄'和'鸡蛋',厨子返回给你'番茄炒鸡蛋';给厨子'白糖'和'黄瓜',厨子返回给你'白糖拌黄瓜' class TomatoesAndEgg: def __init__(self): self.data = "男士喜欢吃番茄炒蛋" def getData(self): return self.data class SugarAndCucumber: def __init__(self): self.data = 123456 def getData(self): return self.data # 工厂方法: 根据传入参数的不同, 而返回对应的对象def cook_factory(sex): if sex == "man": food = TomatoesAndEgg elif sex == "woman": food = SugarAndCucumber else: raise ValueError("请出入正确的性别: &#123;&#125;".format(sex)) return food() if __name__ == "__main__": man = cook_factory("man") woman = cook_factory("woman") data_man = man.getData() # 返回String类型数据 data_woman = woman.getData() # 返回int类型数据 # getData()返回不同类型的数据, 这在实际开发中是很常见的 print(data_man) # =&gt; 男士喜欢吃番茄炒蛋 print(data_woman) # =&gt; 123456]]></content>
  </entry>
  <entry>
    <title><![CDATA[FastDFS]]></title>
    <url>%2F2018%2F09%2F06%2FFastDFS%2F</url>
    <content type="text"><![CDATA[什么是FastFDSFastDFS 是用 c 语言编写的一款开源的分布式文件系统。FastDFS 为互联网量身定制， 充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。FastDFS 架构包括 Tracker server 和 Storage server。客户端请求 Tracker server 进行文 件上传、下载，通过 Tracker server 调度最终由 Storage server 完成文件上传和下载。 Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些 策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。 Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上， Storageserver 没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将 storage 称为存储服务器。 Tracker: 管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。 Storage: 实际保存文件， Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Celery]]></title>
    <url>%2F2018%2F09%2F06%2FCelery%2F</url>
    <content type="text"><![CDATA[Celery介绍1.Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理。用于解决程序中耗时的任务。2.优点：简单，高可用，快速，灵活3.Celery安装和使用：Celery默认brober是Rabbit MQ，可以改为Redis数据库，只需要配置：brober_url=’redis://127.0.0.1:6379/14’4.项目中异步的执行函数main.py 1234567891011121314151617from celery import Celeryfrom . import configimport os# 设置django的配置os.environ.setdefault("DJANGO_SETTINGS_MODULE", "meiduo.settings")# 创建对象app = Celery('meiduo')# 加载配置app.config_from_object(config)# 初始化任务# 在指定的包中找到tasks.py 文件，在这个文件中找@app.task的函数app.autodiscover_tasks([ 'celery_tasks.sms', 'celery_tasks.email', 'celery_tasks.html']) 在异步包中添加需要执行异步的任务tasks 1234567from utils.ytx_sdk.sendSMS import CCPfrom celery_tasks.main import app@app.task(name='sms_send')def sms_send(mobile, sms_code, expires, template_id): # CCP.sendTemplateSMS(mobile, sms_code, expires, template_id) print(sms_code) 6.在需要的视图中执行异步任务：异步对象名.delay(任务所需参数）——–调用异步任务7.启动celery服务celery -A celery_tasks.main worker -l info8.celery构架组成：中间代理人：brober任务执行单元worker，也叫职程执行结果存储backend]]></content>
  </entry>
  <entry>
    <title><![CDATA[Restful风格]]></title>
    <url>%2F2018%2F09%2F06%2FRestful%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[Rest即Representational State Transfer ,直译为‘表现层状态转化’，最大的几个特点是：资源， 统一接口，URI和无状态。 Restful风格特点1.资源：以json(或其他Representation)为载体的、面向用户的一组数据集。2.统一接口：Restful规定数据的操作，增删改查分别对应着Http方法，GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。即：GET（SELECT）：从服务器取出资源（一项或多项）。POST（CREATE）：在服务器新建一个资源。PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。DELETE（DELETE）：从服务器删除资源。 URI可以用一个URI（统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。 无状态所谓无状态的，即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。因为Restful风格是无状态的，所以认证机制就尤为重要，常用的认证机制有：Basic auth，token auth和OAuth。]]></content>
      <tags>
        <tag>Restful风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVT与MCV]]></title>
    <url>%2F2018%2F09%2F06%2FMVT%E4%B8%8EMCV%2F</url>
    <content type="text"><![CDATA[MVC的核心思想：解耦，让不同的代码之间降低耦合，增强代码的可移植性和可扩展性，实现向后兼容。 Web MVC各部分的功能：1.Model：主要封装了对数据库层的的访问，对数据库中的数据进行增，删，改，查操作。2.View：用于封装结果，生成页面html内容与用户进行交互。3.Controller：用于接受请求，处理业务逻辑，与Model和View交互，返回结果。 MVT： Django 遵循MVC设计，并有一个专有名词：MVT MVT各部分的功能1.Model： 负责与数据库交互，进行数据操作。2.View：与MVC中的C的功能一样，接受请求，处理业务，返回应答。3.Template： 与MVC中的V的功能一样，负责封装要返回的html。]]></content>
  </entry>
  <entry>
    <title><![CDATA[python的PEP8规范]]></title>
    <url>%2F2018%2F09%2F06%2FPEP8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[PEP8 Python 编码规范代码编程 缩进，4个空格的缩进，不使用Tab，更不能混合使用Tab和空格。 每行最大长度79，换行可以使用反斜杠，最好使用圆括号。 类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。 文档编排1.模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。2.不要在一句import中多个库，比如import os, sys不推荐。3.如果采用from XX import XX引用库，可以省略‘module.’，都是可能出现命名冲突，这时就要采用import XX。 空格的使用总体原则，避免不必要的空格。 1 各种右括号前不要加空格。2 逗号、冒号、分号前不要加空格。3 函数的左括号前不要加空格。如Func(1)。4 序列的左括号前不要加空格。如list[2]。5 操作符左右各加一个空格，不要为了对齐增加空格。6 函数默认参数使用的赋值符左右省略空格。7 不要将多句语句写在同一行，尽管使用‘；’允许。8 if/for/while语句中，即使执行语句只有一句，也必须另起一行。 注释 总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！ 注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。 命名规范总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。 1 尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。2 模块命名尽量短小，使用全部小写的方式，可以使用下划线。3 包命名尽量短小，使用全部小写的方式，不可以使用下划线。4 类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。5 异常命名使用CapWords+Error后缀的方式。6 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是all机制;二是前缀一个下划线。7 函数命名使用全部小写的方式，可以使用下划线。8 常量命名使用全部大写的方式，可以使用下划线。9 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。9 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。11 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。12 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明a,访问时，只能通过Foo._Fooa，避免歧义。如果子类也叫Foo，那就无能为力了。13 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。 编码建议1 编码中考虑到其他python实现的效率等问题，比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。2 尽可能使用‘is’‘is not’取代‘==’，比如if x is not None 要优于if x。3 使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自Exception。4 异常中不要使用裸露的except，except后跟具体的exceptions。5 异常中try的代码尽可能少。]]></content>
      <tags>
        <tag>PEP8规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
